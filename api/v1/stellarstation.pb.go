// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stellarstation/api/v1/stellarstation.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	orbit "github.com/infostellarinc/go-stellarstation/api/v1/orbit"
	radio "github.com/infostellarinc/go-stellarstation/api/v1/radio"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The priority level of a plan.
type Priority int32

const (
	Priority_LOW    Priority = 0
	Priority_MEDIUM Priority = 1
	Priority_HIGH   Priority = 2
)

var Priority_name = map[int32]string{
	0: "LOW",
	1: "MEDIUM",
	2: "HIGH",
}

var Priority_value = map[string]int32{
	"LOW":    0,
	"MEDIUM": 1,
	"HIGH":   2,
}

func (x Priority) String() string {
	return proto.EnumName(Priority_name, int32(x))
}

func (Priority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{0}
}

// The type of data available at the above URL.
type TelemetryMetadata_DataType int32

const (
	// Raw IQ data.
	TelemetryMetadata_RAW TelemetryMetadata_DataType = 0
	// Demodulated IQ data.
	TelemetryMetadata_DEMODULATED TelemetryMetadata_DataType = 1
	// Decoded data.
	TelemetryMetadata_DECODED TelemetryMetadata_DataType = 2
)

var TelemetryMetadata_DataType_name = map[int32]string{
	0: "RAW",
	1: "DEMODULATED",
	2: "DECODED",
}

var TelemetryMetadata_DataType_value = map[string]int32{
	"RAW":         0,
	"DEMODULATED": 1,
	"DECODED":     2,
}

func (x TelemetryMetadata_DataType) String() string {
	return proto.EnumName(TelemetryMetadata_DataType_name, int32(x))
}

func (TelemetryMetadata_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{18, 0}
}

// A description of the status of a plan.
type Plan_Status int32

const (
	// The plan is reserved for execution in the future at `aos_time`.
	Plan_RESERVED Plan_Status = 0
	// The plan is currently executing and will end in the future at `los_time`.
	Plan_EXECUTING Plan_Status = 1
	// The plan already finished executing successfully.
	Plan_SUCCEEDED Plan_Status = 2
	// The plan failed to execute correctly.
	Plan_FAILED Plan_Status = 3
	// The plan was canceled. This can be explicitly by calling `CancelPlan` or implicit due to
	// cancellation by the ground station in the plan (e.g., due to bad weather).
	Plan_CANCELED Plan_Status = 4
	// The plan completed execution and telemetry data is being processed.
	Plan_PROCESSING Plan_Status = 5
)

var Plan_Status_name = map[int32]string{
	0: "RESERVED",
	1: "EXECUTING",
	2: "SUCCEEDED",
	3: "FAILED",
	4: "CANCELED",
	5: "PROCESSING",
}

var Plan_Status_value = map[string]int32{
	"RESERVED":   0,
	"EXECUTING":  1,
	"SUCCEEDED":  2,
	"FAILED":     3,
	"CANCELED":   4,
	"PROCESSING": 5,
}

func (x Plan_Status) String() string {
	return proto.EnumName(Plan_Status_name, int32(x))
}

func (Plan_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{19, 0}
}

// The source of the TLE.
type SetTleSourceRequest_Source int32

const (
	// This is not allowed and will cause an error.
	SetTleSourceRequest_UNKNOWN SetTleSourceRequest_Source = 0
	// Provided by NORAD.
	SetTleSourceRequest_NORAD SetTleSourceRequest_Source = 1
	// Manually provided by the owner of the satellite.
	SetTleSourceRequest_MANUAL SetTleSourceRequest_Source = 2
)

var SetTleSourceRequest_Source_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORAD",
	2: "MANUAL",
}

var SetTleSourceRequest_Source_value = map[string]int32{
	"UNKNOWN": 0,
	"NORAD":   1,
	"MANUAL":  2,
}

func (x SetTleSourceRequest_Source) String() string {
	return proto.EnumName(SetTleSourceRequest_Source_name, int32(x))
}

func (SetTleSourceRequest_Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{24, 0}
}

// Request for the `OpenSatelliteStream` method.
//
// Next ID: 12
type SatelliteStreamRequest struct {
	// The ID of the satellite to open a stream with. The ID of a satellite can be found on the
	// StellarStation Console page for the satellite.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The ID of the plan to open a stream for. If `plan_id` is set, only messages for the provided
	// plan ID will be returned on this stream. A valid `plan_id` can be found in the response for
	// the `ListPlans` method or on the StellarStation Console page for the satellite.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	PlanId string `protobuf:"bytes,11,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The `SatelliteStreamResponse.stream_id` from a previously opened stream to resume. If the
	// specified stream has already expired or been closed, the stream is closed with a `ABORTED`
	// error.
	StreamId string `protobuf:"bytes,2,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// Whether monitoring events should be returned by the stream in
	// `SatelliteStreamResponse.stream_event`. If set in the first request of the stream, events of
	// type `StreamEvent` will be returned throughout the lifetime of the stream.
	EnableEvents bool `protobuf:"varint,5,opt,name=enable_events,json=enableEvents,proto3" json:"enable_events,omitempty"`
	// A unique ID identifying this request. If `enable_events` is true and this is filled, events
	// returned in `SatelliteStreamResponse.stream_event` that correspond to this request will have
	// this value copied into `StreamEvent.request_id` for correlation. The API will treat this as an
	// opaque identifier which can be set to any value, e.g., to the same value as the request ID or
	// command number in a downstream system. For simple cases, it is often simplest to set this to a
	// standard UUID.
	RequestId string `protobuf:"bytes,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// A request to send on the satellite stream. Currently only command sending to the satellite is
	// supported. The request does not need to be filled on the first request to
	// `OpenSatelliteStream`.
	//
	// Types that are valid to be assigned to Request:
	//	*SatelliteStreamRequest_SendSatelliteCommandsRequest
	//	*SatelliteStreamRequest_GroundStationConfigurationRequest
	//	*SatelliteStreamRequest_TelemetryReceivedAck
	Request isSatelliteStreamRequest_Request `protobuf_oneof:"Request"`
	// The `Framing` types to accept, for satellites that have been configured for multiple framings
	// (e.g., IQ + AX25). If empty, all framings produced by the satellite will be returned.
	AcceptedFraming []Framing `protobuf:"varint,4,rep,packed,name=accepted_framing,json=acceptedFraming,proto3,enum=stellarstation.api.v1.Framing" json:"accepted_framing,omitempty"`
	// Optional. The `ReceiveTelemetryResponse.message_ack_id` of the most recently received telemetry.
	// This may be specified in attempt to resume streaming after a connection or application error. If
	// specified, the server will attempt to resume transfer assuming the provided value is that of the
	// most recent Telemetry received & processed by the client. If not specified (or if provided value
	// is invalid), server will resume streaming from the most recent telemetry message sent by the server
	// which may or may not have been received by the client.
	//
	// This feature is only available if enable_flow_control is true.
	// This feature may not be available for Out-of-order-allowed-satellites.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	ResumeStreamMessageAckId string `protobuf:"bytes,8,opt,name=resume_stream_message_ack_id,json=resumeStreamMessageAckId,proto3" json:"resume_stream_message_ack_id,omitempty"`
	// Whether flow control is enabled on the client side. If set to true, client must respond to each
	// ReceiveTelemetryResponse received with a corresponding ReceiveTelemetryAck message.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	EnableFlowControl    bool     `protobuf:"varint,10,opt,name=enable_flow_control,json=enableFlowControl,proto3" json:"enable_flow_control,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SatelliteStreamRequest) Reset()         { *m = SatelliteStreamRequest{} }
func (m *SatelliteStreamRequest) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamRequest) ProtoMessage()    {}
func (*SatelliteStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{0}
}

func (m *SatelliteStreamRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteStreamRequest.Unmarshal(m, b)
}
func (m *SatelliteStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteStreamRequest.Marshal(b, m, deterministic)
}
func (m *SatelliteStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamRequest.Merge(m, src)
}
func (m *SatelliteStreamRequest) XXX_Size() int {
	return xxx_messageInfo_SatelliteStreamRequest.Size(m)
}
func (m *SatelliteStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamRequest proto.InternalMessageInfo

func (m *SatelliteStreamRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetEnableEvents() bool {
	if m != nil {
		return m.EnableEvents
	}
	return false
}

func (m *SatelliteStreamRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type isSatelliteStreamRequest_Request interface {
	isSatelliteStreamRequest_Request()
}

type SatelliteStreamRequest_SendSatelliteCommandsRequest struct {
	SendSatelliteCommandsRequest *SendSatelliteCommandsRequest `protobuf:"bytes,3,opt,name=send_satellite_commands_request,json=sendSatelliteCommandsRequest,proto3,oneof"`
}

type SatelliteStreamRequest_GroundStationConfigurationRequest struct {
	GroundStationConfigurationRequest *GroundStationConfigurationRequest `protobuf:"bytes,7,opt,name=ground_station_configuration_request,json=groundStationConfigurationRequest,proto3,oneof"`
}

type SatelliteStreamRequest_TelemetryReceivedAck struct {
	TelemetryReceivedAck *ReceiveTelemetryAck `protobuf:"bytes,9,opt,name=telemetry_received_ack,json=telemetryReceivedAck,proto3,oneof"`
}

func (*SatelliteStreamRequest_SendSatelliteCommandsRequest) isSatelliteStreamRequest_Request() {}

func (*SatelliteStreamRequest_GroundStationConfigurationRequest) isSatelliteStreamRequest_Request() {}

func (*SatelliteStreamRequest_TelemetryReceivedAck) isSatelliteStreamRequest_Request() {}

func (m *SatelliteStreamRequest) GetRequest() isSatelliteStreamRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SatelliteStreamRequest) GetSendSatelliteCommandsRequest() *SendSatelliteCommandsRequest {
	if x, ok := m.GetRequest().(*SatelliteStreamRequest_SendSatelliteCommandsRequest); ok {
		return x.SendSatelliteCommandsRequest
	}
	return nil
}

func (m *SatelliteStreamRequest) GetGroundStationConfigurationRequest() *GroundStationConfigurationRequest {
	if x, ok := m.GetRequest().(*SatelliteStreamRequest_GroundStationConfigurationRequest); ok {
		return x.GroundStationConfigurationRequest
	}
	return nil
}

func (m *SatelliteStreamRequest) GetTelemetryReceivedAck() *ReceiveTelemetryAck {
	if x, ok := m.GetRequest().(*SatelliteStreamRequest_TelemetryReceivedAck); ok {
		return x.TelemetryReceivedAck
	}
	return nil
}

func (m *SatelliteStreamRequest) GetAcceptedFraming() []Framing {
	if m != nil {
		return m.AcceptedFraming
	}
	return nil
}

func (m *SatelliteStreamRequest) GetResumeStreamMessageAckId() string {
	if m != nil {
		return m.ResumeStreamMessageAckId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetEnableFlowControl() bool {
	if m != nil {
		return m.EnableFlowControl
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SatelliteStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SatelliteStreamRequest_SendSatelliteCommandsRequest)(nil),
		(*SatelliteStreamRequest_GroundStationConfigurationRequest)(nil),
		(*SatelliteStreamRequest_TelemetryReceivedAck)(nil),
	}
}

// A request to send commands to a satellite.
//
// Next ID: 4
type SendSatelliteCommandsRequest struct {
	// The command frames to send to the satellite. All commands will be transmitted in sequence
	// immediately, during which time telemetry will not be received. After all commands have been
	// transmitted, telemetry receive will be immediately re-enabled. The maximum size of each command
	// is 2MB. If a command larger than 2MB is received, the stream will be closed with a
	// `RESOURCE_EXHAUSTED` error.
	Command [][]byte `protobuf:"bytes,2,rep,name=command,proto3" json:"command,omitempty"`
	// The ID of the channel set to be used when sending the command. Required if two uplink-capable
	// plans are simultaneously executing. If not provided and only one plan is executing, the
	// channel set will be automatically determined.
	//
	// If a channel set without an uplink component is provided or two uplink-capable plans are
	// simultaneously executing and no ID is provided, the command will be ignored.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	ChannelSetId         string   `protobuf:"bytes,3,opt,name=channel_set_id,json=channelSetId,proto3" json:"channel_set_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendSatelliteCommandsRequest) Reset()         { *m = SendSatelliteCommandsRequest{} }
func (m *SendSatelliteCommandsRequest) String() string { return proto.CompactTextString(m) }
func (*SendSatelliteCommandsRequest) ProtoMessage()    {}
func (*SendSatelliteCommandsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{1}
}

func (m *SendSatelliteCommandsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Unmarshal(m, b)
}
func (m *SendSatelliteCommandsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Marshal(b, m, deterministic)
}
func (m *SendSatelliteCommandsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSatelliteCommandsRequest.Merge(m, src)
}
func (m *SendSatelliteCommandsRequest) XXX_Size() int {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Size(m)
}
func (m *SendSatelliteCommandsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSatelliteCommandsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendSatelliteCommandsRequest proto.InternalMessageInfo

func (m *SendSatelliteCommandsRequest) GetCommand() [][]byte {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *SendSatelliteCommandsRequest) GetChannelSetId() string {
	if m != nil {
		return m.ChannelSetId
	}
	return ""
}

// A request to modify configuration of ground station hardware.
//
// Next ID: 3
// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
//         incompatible ways in the future.
type GroundStationConfigurationRequest struct {
	// A request to modify transmitter configuration at a ground station.
	TransmitterConfigurationRequest *TransmitterConfigurationRequest `protobuf:"bytes,1,opt,name=transmitter_configuration_request,json=transmitterConfigurationRequest,proto3" json:"transmitter_configuration_request,omitempty"`
	// A request to modify receiver configuration at a ground station.
	ReceiverConfigurationRequest *ReceiverConfigurationRequest `protobuf:"bytes,2,opt,name=receiver_configuration_request,json=receiverConfigurationRequest,proto3" json:"receiver_configuration_request,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}                      `json:"-"`
	XXX_unrecognized             []byte                        `json:"-"`
	XXX_sizecache                int32                         `json:"-"`
}

func (m *GroundStationConfigurationRequest) Reset()         { *m = GroundStationConfigurationRequest{} }
func (m *GroundStationConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*GroundStationConfigurationRequest) ProtoMessage()    {}
func (*GroundStationConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{2}
}

func (m *GroundStationConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroundStationConfigurationRequest.Unmarshal(m, b)
}
func (m *GroundStationConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroundStationConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *GroundStationConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroundStationConfigurationRequest.Merge(m, src)
}
func (m *GroundStationConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_GroundStationConfigurationRequest.Size(m)
}
func (m *GroundStationConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GroundStationConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GroundStationConfigurationRequest proto.InternalMessageInfo

func (m *GroundStationConfigurationRequest) GetTransmitterConfigurationRequest() *TransmitterConfigurationRequest {
	if m != nil {
		return m.TransmitterConfigurationRequest
	}
	return nil
}

func (m *GroundStationConfigurationRequest) GetReceiverConfigurationRequest() *ReceiverConfigurationRequest {
	if m != nil {
		return m.ReceiverConfigurationRequest
	}
	return nil
}

// An ack message for client to notify server of sucessful receive of a ReceiveTelemetryResponse message.
//
// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
//         incompatible ways in the future.
type ReceiveTelemetryAck struct {
	// The `ReceiveTelemetryResponse.message_ack_id` value of the telemetry message received
	MessageAckId string `protobuf:"bytes,1,opt,name=message_ack_id,json=messageAckId,proto3" json:"message_ack_id,omitempty"`
	// Optional. The local timestamp of message reception, used for statistics collection.
	ReceivedTimestamp    *timestamp.Timestamp `protobuf:"bytes,2,opt,name=received_timestamp,json=receivedTimestamp,proto3" json:"received_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ReceiveTelemetryAck) Reset()         { *m = ReceiveTelemetryAck{} }
func (m *ReceiveTelemetryAck) String() string { return proto.CompactTextString(m) }
func (*ReceiveTelemetryAck) ProtoMessage()    {}
func (*ReceiveTelemetryAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{3}
}

func (m *ReceiveTelemetryAck) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiveTelemetryAck.Unmarshal(m, b)
}
func (m *ReceiveTelemetryAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiveTelemetryAck.Marshal(b, m, deterministic)
}
func (m *ReceiveTelemetryAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTelemetryAck.Merge(m, src)
}
func (m *ReceiveTelemetryAck) XXX_Size() int {
	return xxx_messageInfo_ReceiveTelemetryAck.Size(m)
}
func (m *ReceiveTelemetryAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTelemetryAck.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTelemetryAck proto.InternalMessageInfo

func (m *ReceiveTelemetryAck) GetMessageAckId() string {
	if m != nil {
		return m.MessageAckId
	}
	return ""
}

func (m *ReceiveTelemetryAck) GetReceivedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.ReceivedTimestamp
	}
	return nil
}

// A request to configure a transmitter at a ground station. Default state of these parameters
// depends on hardware configuration at each ground station. Please check TransmitterConfiguration
// and TransmitterState in monitoring message.
//
// Not all configuration requests are supported by some transmitters. If a field isn't set,
// the configuration will not be changed.
//
// Next ID: 7
type TransmitterConfigurationRequest struct {
	// Enable carrier transmission.
	EnableCarrier *wrappers.BoolValue `protobuf:"bytes,1,opt,name=enable_carrier,json=enableCarrier,proto3" json:"enable_carrier,omitempty"`
	// Enable IF modulation.
	EnableIfModulation *wrappers.BoolValue `protobuf:"bytes,2,opt,name=enable_if_modulation,json=enableIfModulation,proto3" json:"enable_if_modulation,omitempty"`
	// Enable idle pattern transmission.
	EnableIdlePattern *wrappers.BoolValue `protobuf:"bytes,3,opt,name=enable_idle_pattern,json=enableIdlePattern,proto3" json:"enable_idle_pattern,omitempty"`
	// Enable IF sweep.
	EnableIfSweep *wrappers.BoolValue `protobuf:"bytes,4,opt,name=enable_if_sweep,json=enableIfSweep,proto3" json:"enable_if_sweep,omitempty"`
	// Bitrate of the transmitter
	Bitrate *wrappers.FloatValue `protobuf:"bytes,5,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	// Modulation of the transmitter. Note that the default modulation is DISABLED and
	// will be ignored. There is no way to disable modulation using this method.
	Modulation           radio.Modulation `protobuf:"varint,6,opt,name=modulation,proto3,enum=stellarstation.api.v1.radio.Modulation" json:"modulation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TransmitterConfigurationRequest) Reset()         { *m = TransmitterConfigurationRequest{} }
func (m *TransmitterConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*TransmitterConfigurationRequest) ProtoMessage()    {}
func (*TransmitterConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{4}
}

func (m *TransmitterConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransmitterConfigurationRequest.Unmarshal(m, b)
}
func (m *TransmitterConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransmitterConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *TransmitterConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransmitterConfigurationRequest.Merge(m, src)
}
func (m *TransmitterConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_TransmitterConfigurationRequest.Size(m)
}
func (m *TransmitterConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransmitterConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransmitterConfigurationRequest proto.InternalMessageInfo

func (m *TransmitterConfigurationRequest) GetEnableCarrier() *wrappers.BoolValue {
	if m != nil {
		return m.EnableCarrier
	}
	return nil
}

func (m *TransmitterConfigurationRequest) GetEnableIfModulation() *wrappers.BoolValue {
	if m != nil {
		return m.EnableIfModulation
	}
	return nil
}

func (m *TransmitterConfigurationRequest) GetEnableIdlePattern() *wrappers.BoolValue {
	if m != nil {
		return m.EnableIdlePattern
	}
	return nil
}

func (m *TransmitterConfigurationRequest) GetEnableIfSweep() *wrappers.BoolValue {
	if m != nil {
		return m.EnableIfSweep
	}
	return nil
}

func (m *TransmitterConfigurationRequest) GetBitrate() *wrappers.FloatValue {
	if m != nil {
		return m.Bitrate
	}
	return nil
}

func (m *TransmitterConfigurationRequest) GetModulation() radio.Modulation {
	if m != nil {
		return m.Modulation
	}
	return radio.Modulation_DISABLED
}

// A request to configure a receiver at a ground station. Default state of these parameters
// depends on hardware configuration at each ground station. Please check ReceiverConfiguration
// and ReceiverState in monitoring message.
//
// Not all configuration requests are supported by some receivers. If a field isn't set,
// the configuration will not be changed.
//
// Next ID: 3
type ReceiverConfigurationRequest struct {
	// Bitrate of the receiver.
	Bitrate *wrappers.FloatValue `protobuf:"bytes,1,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	// Modulation of the receiver. Note that the default modulation is DISABLED and
	// will be ignored. There is no way to disable modulation using this method.
	Modulation           radio.Modulation `protobuf:"varint,2,opt,name=modulation,proto3,enum=stellarstation.api.v1.radio.Modulation" json:"modulation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ReceiverConfigurationRequest) Reset()         { *m = ReceiverConfigurationRequest{} }
func (m *ReceiverConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*ReceiverConfigurationRequest) ProtoMessage()    {}
func (*ReceiverConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{5}
}

func (m *ReceiverConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiverConfigurationRequest.Unmarshal(m, b)
}
func (m *ReceiverConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiverConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *ReceiverConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiverConfigurationRequest.Merge(m, src)
}
func (m *ReceiverConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_ReceiverConfigurationRequest.Size(m)
}
func (m *ReceiverConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiverConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiverConfigurationRequest proto.InternalMessageInfo

func (m *ReceiverConfigurationRequest) GetBitrate() *wrappers.FloatValue {
	if m != nil {
		return m.Bitrate
	}
	return nil
}

func (m *ReceiverConfigurationRequest) GetModulation() radio.Modulation {
	if m != nil {
		return m.Modulation
	}
	return radio.Modulation_DISABLED
}

// A response from the `OpenSatelliteStream` method.
type SatelliteStreamResponse struct {
	// The ID of this stream, which can be used in a subsequent call to `OpenSatelliteStream` to
	// resume this stream on interruption (e.g., if a network failure causes the connection to be
	// closed mid-stream). Telemetry received on a previously opened stream with no current listener
	// will be buffered for a maximum of 1 minute, and the stream itself will be cancelled and no more
	// buffering will occur if no client resumes the stream with `OpenSatelliteStream` within 10
	// minutes.
	StreamId string `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// A response on the stream. Currently the only types of response are telemetry received from the
	// satellite and stream events.
	//
	// Types that are valid to be assigned to Response:
	//	*SatelliteStreamResponse_ReceiveTelemetryResponse
	//	*SatelliteStreamResponse_StreamEvent
	Response             isSatelliteStreamResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *SatelliteStreamResponse) Reset()         { *m = SatelliteStreamResponse{} }
func (m *SatelliteStreamResponse) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamResponse) ProtoMessage()    {}
func (*SatelliteStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{6}
}

func (m *SatelliteStreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteStreamResponse.Unmarshal(m, b)
}
func (m *SatelliteStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteStreamResponse.Marshal(b, m, deterministic)
}
func (m *SatelliteStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamResponse.Merge(m, src)
}
func (m *SatelliteStreamResponse) XXX_Size() int {
	return xxx_messageInfo_SatelliteStreamResponse.Size(m)
}
func (m *SatelliteStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamResponse proto.InternalMessageInfo

func (m *SatelliteStreamResponse) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type isSatelliteStreamResponse_Response interface {
	isSatelliteStreamResponse_Response()
}

type SatelliteStreamResponse_ReceiveTelemetryResponse struct {
	ReceiveTelemetryResponse *ReceiveTelemetryResponse `protobuf:"bytes,2,opt,name=receive_telemetry_response,json=receiveTelemetryResponse,proto3,oneof"`
}

type SatelliteStreamResponse_StreamEvent struct {
	StreamEvent *StreamEvent `protobuf:"bytes,3,opt,name=stream_event,json=streamEvent,proto3,oneof"`
}

func (*SatelliteStreamResponse_ReceiveTelemetryResponse) isSatelliteStreamResponse_Response() {}

func (*SatelliteStreamResponse_StreamEvent) isSatelliteStreamResponse_Response() {}

func (m *SatelliteStreamResponse) GetResponse() isSatelliteStreamResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SatelliteStreamResponse) GetReceiveTelemetryResponse() *ReceiveTelemetryResponse {
	if x, ok := m.GetResponse().(*SatelliteStreamResponse_ReceiveTelemetryResponse); ok {
		return x.ReceiveTelemetryResponse
	}
	return nil
}

func (m *SatelliteStreamResponse) GetStreamEvent() *StreamEvent {
	if x, ok := m.GetResponse().(*SatelliteStreamResponse_StreamEvent); ok {
		return x.StreamEvent
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SatelliteStreamResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SatelliteStreamResponse_ReceiveTelemetryResponse)(nil),
		(*SatelliteStreamResponse_StreamEvent)(nil),
	}
}

// A response from a satellite containing telemetry.
type ReceiveTelemetryResponse struct {
	// The telemetry received.
	Telemetry []*Telemetry `protobuf:"bytes,1,rep,name=telemetry,proto3" json:"telemetry,omitempty"`
	// The ID of the plan the telemetry was received for.
	PlanId string `protobuf:"bytes,2,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The ID to be used to when creating a `ReceiveTelemetryAck.message_ack_id` response
	//
	// This value may not be available for Out-of-order-allowed-satellites
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	MessageAckId         string   `protobuf:"bytes,3,opt,name=message_ack_id,json=messageAckId,proto3" json:"message_ack_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveTelemetryResponse) Reset()         { *m = ReceiveTelemetryResponse{} }
func (m *ReceiveTelemetryResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiveTelemetryResponse) ProtoMessage()    {}
func (*ReceiveTelemetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{7}
}

func (m *ReceiveTelemetryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiveTelemetryResponse.Unmarshal(m, b)
}
func (m *ReceiveTelemetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiveTelemetryResponse.Marshal(b, m, deterministic)
}
func (m *ReceiveTelemetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTelemetryResponse.Merge(m, src)
}
func (m *ReceiveTelemetryResponse) XXX_Size() int {
	return xxx_messageInfo_ReceiveTelemetryResponse.Size(m)
}
func (m *ReceiveTelemetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTelemetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTelemetryResponse proto.InternalMessageInfo

func (m *ReceiveTelemetryResponse) GetTelemetry() []*Telemetry {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

func (m *ReceiveTelemetryResponse) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *ReceiveTelemetryResponse) GetMessageAckId() string {
	if m != nil {
		return m.MessageAckId
	}
	return ""
}

// Request for the `CancelPlan` method.
type CancelPlanRequest struct {
	// The id of the plan to cancel, i.e., the value of `Plan.id`.
	PlanId               string   `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelPlanRequest) Reset()         { *m = CancelPlanRequest{} }
func (m *CancelPlanRequest) String() string { return proto.CompactTextString(m) }
func (*CancelPlanRequest) ProtoMessage()    {}
func (*CancelPlanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{8}
}

func (m *CancelPlanRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelPlanRequest.Unmarshal(m, b)
}
func (m *CancelPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelPlanRequest.Marshal(b, m, deterministic)
}
func (m *CancelPlanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelPlanRequest.Merge(m, src)
}
func (m *CancelPlanRequest) XXX_Size() int {
	return xxx_messageInfo_CancelPlanRequest.Size(m)
}
func (m *CancelPlanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelPlanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelPlanRequest proto.InternalMessageInfo

func (m *CancelPlanRequest) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

// Response for the `CancelPlan` method.
type CancelPlanResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelPlanResponse) Reset()         { *m = CancelPlanResponse{} }
func (m *CancelPlanResponse) String() string { return proto.CompactTextString(m) }
func (*CancelPlanResponse) ProtoMessage()    {}
func (*CancelPlanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{9}
}

func (m *CancelPlanResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelPlanResponse.Unmarshal(m, b)
}
func (m *CancelPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelPlanResponse.Marshal(b, m, deterministic)
}
func (m *CancelPlanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelPlanResponse.Merge(m, src)
}
func (m *CancelPlanResponse) XXX_Size() int {
	return xxx_messageInfo_CancelPlanResponse.Size(m)
}
func (m *CancelPlanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelPlanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelPlanResponse proto.InternalMessageInfo

// Request for the `ListUpcomingAvailablePasses` method.
type ListUpcomingAvailablePassesRequest struct {
	// The ID of the satellite to list passes for. The ID of a satellite can be found on the
	// StellarStation Console page for the satellite.
	SatelliteId          string   `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUpcomingAvailablePassesRequest) Reset()         { *m = ListUpcomingAvailablePassesRequest{} }
func (m *ListUpcomingAvailablePassesRequest) String() string { return proto.CompactTextString(m) }
func (*ListUpcomingAvailablePassesRequest) ProtoMessage()    {}
func (*ListUpcomingAvailablePassesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{10}
}

func (m *ListUpcomingAvailablePassesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Unmarshal(m, b)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Marshal(b, m, deterministic)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUpcomingAvailablePassesRequest.Merge(m, src)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Size() int {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Size(m)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUpcomingAvailablePassesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUpcomingAvailablePassesRequest proto.InternalMessageInfo

func (m *ListUpcomingAvailablePassesRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

// Response for the `ListUpcomingAvailablePasses` method.
type ListUpcomingAvailablePassesResponse struct {
	// The upcoming, schedulable passes for the satellite.
	Pass                 []*Pass  `protobuf:"bytes,1,rep,name=pass,proto3" json:"pass,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUpcomingAvailablePassesResponse) Reset()         { *m = ListUpcomingAvailablePassesResponse{} }
func (m *ListUpcomingAvailablePassesResponse) String() string { return proto.CompactTextString(m) }
func (*ListUpcomingAvailablePassesResponse) ProtoMessage()    {}
func (*ListUpcomingAvailablePassesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{11}
}

func (m *ListUpcomingAvailablePassesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Unmarshal(m, b)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Marshal(b, m, deterministic)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUpcomingAvailablePassesResponse.Merge(m, src)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Size() int {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Size(m)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUpcomingAvailablePassesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUpcomingAvailablePassesResponse proto.InternalMessageInfo

func (m *ListUpcomingAvailablePassesResponse) GetPass() []*Pass {
	if m != nil {
		return m.Pass
	}
	return nil
}

// Request for the `ReservePass` method.
type ReservePassRequest struct {
	// The token that specifies the pass, as returned in `Pass.reservation_token` or one of the
	// `Pass.channel_set_token.reservation_token` values.
	ReservationToken     string   `protobuf:"bytes,1,opt,name=reservation_token,json=reservationToken,proto3" json:"reservation_token,omitempty"`
	Priority             Priority `protobuf:"varint,2,opt,name=priority,proto3,enum=stellarstation.api.v1.Priority" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservePassRequest) Reset()         { *m = ReservePassRequest{} }
func (m *ReservePassRequest) String() string { return proto.CompactTextString(m) }
func (*ReservePassRequest) ProtoMessage()    {}
func (*ReservePassRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{12}
}

func (m *ReservePassRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservePassRequest.Unmarshal(m, b)
}
func (m *ReservePassRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservePassRequest.Marshal(b, m, deterministic)
}
func (m *ReservePassRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservePassRequest.Merge(m, src)
}
func (m *ReservePassRequest) XXX_Size() int {
	return xxx_messageInfo_ReservePassRequest.Size(m)
}
func (m *ReservePassRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservePassRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReservePassRequest proto.InternalMessageInfo

func (m *ReservePassRequest) GetReservationToken() string {
	if m != nil {
		return m.ReservationToken
	}
	return ""
}

func (m *ReservePassRequest) GetPriority() Priority {
	if m != nil {
		return m.Priority
	}
	return Priority_LOW
}

// Response for the `ReservePass` method.
type ReservePassResponse struct {
	// The reserved plan.
	Plan                 *Plan    `protobuf:"bytes,1,opt,name=plan,proto3" json:"plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservePassResponse) Reset()         { *m = ReservePassResponse{} }
func (m *ReservePassResponse) String() string { return proto.CompactTextString(m) }
func (*ReservePassResponse) ProtoMessage()    {}
func (*ReservePassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{13}
}

func (m *ReservePassResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservePassResponse.Unmarshal(m, b)
}
func (m *ReservePassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservePassResponse.Marshal(b, m, deterministic)
}
func (m *ReservePassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservePassResponse.Merge(m, src)
}
func (m *ReservePassResponse) XXX_Size() int {
	return xxx_messageInfo_ReservePassResponse.Size(m)
}
func (m *ReservePassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservePassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReservePassResponse proto.InternalMessageInfo

func (m *ReservePassResponse) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

// Request for the `ListPlans` method.
type ListPlansRequest struct {
	// The ID of the satellite to list plans for. The ID can be found on the StellarStation
	// Console page for the satellite.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The start time of the range of plans to list (inclusive). Only plans with an Acquisition of
	// Signal (AOS) at or after this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosAfter *timestamp.Timestamp `protobuf:"bytes,2,opt,name=aos_after,json=aosAfter,proto3" json:"aos_after,omitempty"`
	// The end time of the range of plans to list (exclusive). Only plans with an Acquisition of
	// Signal (AOS) before this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosBefore            *timestamp.Timestamp `protobuf:"bytes,3,opt,name=aos_before,json=aosBefore,proto3" json:"aos_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListPlansRequest) Reset()         { *m = ListPlansRequest{} }
func (m *ListPlansRequest) String() string { return proto.CompactTextString(m) }
func (*ListPlansRequest) ProtoMessage()    {}
func (*ListPlansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{14}
}

func (m *ListPlansRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPlansRequest.Unmarshal(m, b)
}
func (m *ListPlansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPlansRequest.Marshal(b, m, deterministic)
}
func (m *ListPlansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlansRequest.Merge(m, src)
}
func (m *ListPlansRequest) XXX_Size() int {
	return xxx_messageInfo_ListPlansRequest.Size(m)
}
func (m *ListPlansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlansRequest proto.InternalMessageInfo

func (m *ListPlansRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *ListPlansRequest) GetAosAfter() *timestamp.Timestamp {
	if m != nil {
		return m.AosAfter
	}
	return nil
}

func (m *ListPlansRequest) GetAosBefore() *timestamp.Timestamp {
	if m != nil {
		return m.AosBefore
	}
	return nil
}

// A response from the `ListPlans` method.
type ListPlansResponse struct {
	// The requested list of plans for the satellite.
	Plan                 []*Plan  `protobuf:"bytes,1,rep,name=plan,proto3" json:"plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPlansResponse) Reset()         { *m = ListPlansResponse{} }
func (m *ListPlansResponse) String() string { return proto.CompactTextString(m) }
func (*ListPlansResponse) ProtoMessage()    {}
func (*ListPlansResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{15}
}

func (m *ListPlansResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPlansResponse.Unmarshal(m, b)
}
func (m *ListPlansResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPlansResponse.Marshal(b, m, deterministic)
}
func (m *ListPlansResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlansResponse.Merge(m, src)
}
func (m *ListPlansResponse) XXX_Size() int {
	return xxx_messageInfo_ListPlansResponse.Size(m)
}
func (m *ListPlansResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlansResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlansResponse proto.InternalMessageInfo

func (m *ListPlansResponse) GetPlan() []*Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

// A channel set defines one or both of the uplink and downlink `RadioDeviceConfiguration`s to be
// used when executing a pass. A channel set is unique to a specific satellite, and a satellite may
// have one or more channel sets.
//
// A common example is to have a channel set for TT&C with both uplink and downlink configurations,
// and a second channel set only for mission downlink. In this case it is necessary to select the
// configuration that will be used during plan execution.
type ChannelSet struct {
	// The unique ID of the channel set.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name used to identify the channel set (for example, TT&C UHF).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The radio device configuration used for uplinking.
	//
	// Optional if downlink is set.
	Uplink *radio.RadioDeviceConfiguration `protobuf:"bytes,3,opt,name=uplink,proto3" json:"uplink,omitempty"`
	// The radio device configuration used for downlinking.
	//
	// Optional if uplink is set.
	Downlink             *radio.RadioDeviceConfiguration `protobuf:"bytes,4,opt,name=downlink,proto3" json:"downlink,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ChannelSet) Reset()         { *m = ChannelSet{} }
func (m *ChannelSet) String() string { return proto.CompactTextString(m) }
func (*ChannelSet) ProtoMessage()    {}
func (*ChannelSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{16}
}

func (m *ChannelSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelSet.Unmarshal(m, b)
}
func (m *ChannelSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelSet.Marshal(b, m, deterministic)
}
func (m *ChannelSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelSet.Merge(m, src)
}
func (m *ChannelSet) XXX_Size() int {
	return xxx_messageInfo_ChannelSet.Size(m)
}
func (m *ChannelSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelSet.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelSet proto.InternalMessageInfo

func (m *ChannelSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ChannelSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChannelSet) GetUplink() *radio.RadioDeviceConfiguration {
	if m != nil {
		return m.Uplink
	}
	return nil
}

func (m *ChannelSet) GetDownlink() *radio.RadioDeviceConfiguration {
	if m != nil {
		return m.Downlink
	}
	return nil
}

// A pass during which a satellite can be communicated with from a given ground station.
//
// Next ID: 14
type Pass struct {
	// The time of Acquisition of Signal (AOS) between the ground station and satellite in this pass.
	AosTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=aos_time,json=aosTime,proto3" json:"aos_time,omitempty"`
	// The time of Loss of Signal (LOS) between the ground station and satellite in this pass.
	LosTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=los_time,json=losTime,proto3" json:"los_time,omitempty"`
	// The latitude, in degrees, of the ground station's location.
	GroundStationLatitude float64 `protobuf:"fixed64,4,opt,name=ground_station_latitude,json=groundStationLatitude,proto3" json:"ground_station_latitude,omitempty"`
	// The longitude, in degrees, of the ground station's location.
	GroundStationLongitude float64 `protobuf:"fixed64,5,opt,name=ground_station_longitude,json=groundStationLongitude,proto3" json:"ground_station_longitude,omitempty"`
	// The organization name of the ground station.
	GroundStationOrganizationName string `protobuf:"bytes,12,opt,name=ground_station_organization_name,json=groundStationOrganizationName,proto3" json:"ground_station_organization_name,omitempty"`
	// The ID of the ground station.
	GroundStationId string `protobuf:"bytes,13,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
	// See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	GroundStationCountryCode string `protobuf:"bytes,6,opt,name=ground_station_country_code,json=groundStationCountryCode,proto3" json:"ground_station_country_code,omitempty"`
	// The max elevation during the pass, in degrees.
	MaxElevationDegrees float64 `protobuf:"fixed64,7,opt,name=max_elevation_degrees,json=maxElevationDegrees,proto3" json:"max_elevation_degrees,omitempty"`
	// The time of the max elevation during the pass.
	MaxElevationTime *timestamp.Timestamp `protobuf:"bytes,8,opt,name=max_elevation_time,json=maxElevationTime,proto3" json:"max_elevation_time,omitempty"`
	// List of channel set and corresponding reservation token groupings. Only channel sets that are
	// compatible with this pass's ground station will be present.
	ChannelSetToken      []*Pass_ChannelSetToken `protobuf:"bytes,11,rep,name=channel_set_token,json=channelSetToken,proto3" json:"channel_set_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Pass) Reset()         { *m = Pass{} }
func (m *Pass) String() string { return proto.CompactTextString(m) }
func (*Pass) ProtoMessage()    {}
func (*Pass) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{17}
}

func (m *Pass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pass.Unmarshal(m, b)
}
func (m *Pass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pass.Marshal(b, m, deterministic)
}
func (m *Pass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pass.Merge(m, src)
}
func (m *Pass) XXX_Size() int {
	return xxx_messageInfo_Pass.Size(m)
}
func (m *Pass) XXX_DiscardUnknown() {
	xxx_messageInfo_Pass.DiscardUnknown(m)
}

var xxx_messageInfo_Pass proto.InternalMessageInfo

func (m *Pass) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Pass) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Pass) GetGroundStationLatitude() float64 {
	if m != nil {
		return m.GroundStationLatitude
	}
	return 0
}

func (m *Pass) GetGroundStationLongitude() float64 {
	if m != nil {
		return m.GroundStationLongitude
	}
	return 0
}

func (m *Pass) GetGroundStationOrganizationName() string {
	if m != nil {
		return m.GroundStationOrganizationName
	}
	return ""
}

func (m *Pass) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *Pass) GetGroundStationCountryCode() string {
	if m != nil {
		return m.GroundStationCountryCode
	}
	return ""
}

func (m *Pass) GetMaxElevationDegrees() float64 {
	if m != nil {
		return m.MaxElevationDegrees
	}
	return 0
}

func (m *Pass) GetMaxElevationTime() *timestamp.Timestamp {
	if m != nil {
		return m.MaxElevationTime
	}
	return nil
}

func (m *Pass) GetChannelSetToken() []*Pass_ChannelSetToken {
	if m != nil {
		return m.ChannelSetToken
	}
	return nil
}

// A mapping of channel set to its unique reservation token.
type Pass_ChannelSetToken struct {
	// A channel set that can be reserved.
	ChannelSet *ChannelSet `protobuf:"bytes,1,opt,name=channel_set,json=channelSet,proto3" json:"channel_set,omitempty"`
	// A unique token for this pass, specific to this channel set, that can
	// be used for scheduling it by copying to ReservePassRequest.reservation_token.
	ReservationToken string `protobuf:"bytes,2,opt,name=reservation_token,json=reservationToken,proto3" json:"reservation_token,omitempty"`
	// The price per minute (USD) for this pass and channel set combination.
	UnitPrice            float64  `protobuf:"fixed64,3,opt,name=unit_price,json=unitPrice,proto3" json:"unit_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pass_ChannelSetToken) Reset()         { *m = Pass_ChannelSetToken{} }
func (m *Pass_ChannelSetToken) String() string { return proto.CompactTextString(m) }
func (*Pass_ChannelSetToken) ProtoMessage()    {}
func (*Pass_ChannelSetToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{17, 0}
}

func (m *Pass_ChannelSetToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pass_ChannelSetToken.Unmarshal(m, b)
}
func (m *Pass_ChannelSetToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pass_ChannelSetToken.Marshal(b, m, deterministic)
}
func (m *Pass_ChannelSetToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pass_ChannelSetToken.Merge(m, src)
}
func (m *Pass_ChannelSetToken) XXX_Size() int {
	return xxx_messageInfo_Pass_ChannelSetToken.Size(m)
}
func (m *Pass_ChannelSetToken) XXX_DiscardUnknown() {
	xxx_messageInfo_Pass_ChannelSetToken.DiscardUnknown(m)
}

var xxx_messageInfo_Pass_ChannelSetToken proto.InternalMessageInfo

func (m *Pass_ChannelSetToken) GetChannelSet() *ChannelSet {
	if m != nil {
		return m.ChannelSet
	}
	return nil
}

func (m *Pass_ChannelSetToken) GetReservationToken() string {
	if m != nil {
		return m.ReservationToken
	}
	return ""
}

func (m *Pass_ChannelSetToken) GetUnitPrice() float64 {
	if m != nil {
		return m.UnitPrice
	}
	return 0
}

// Metadata for telemetry downlinked during a pass.
type TelemetryMetadata struct {
	// URL of the data. This URL is valid for one hour after being returned.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The type of data received during downlinking.
	DataType             TelemetryMetadata_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3,enum=stellarstation.api.v1.TelemetryMetadata_DataType" json:"data_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TelemetryMetadata) Reset()         { *m = TelemetryMetadata{} }
func (m *TelemetryMetadata) String() string { return proto.CompactTextString(m) }
func (*TelemetryMetadata) ProtoMessage()    {}
func (*TelemetryMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{18}
}

func (m *TelemetryMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TelemetryMetadata.Unmarshal(m, b)
}
func (m *TelemetryMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TelemetryMetadata.Marshal(b, m, deterministic)
}
func (m *TelemetryMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryMetadata.Merge(m, src)
}
func (m *TelemetryMetadata) XXX_Size() int {
	return xxx_messageInfo_TelemetryMetadata.Size(m)
}
func (m *TelemetryMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryMetadata proto.InternalMessageInfo

func (m *TelemetryMetadata) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *TelemetryMetadata) GetDataType() TelemetryMetadata_DataType {
	if m != nil {
		return m.DataType
	}
	return TelemetryMetadata_RAW
}

// A plan, specifying a time range within which a satellite will be communicated with.
//
// Next ID: 22
type Plan struct {
	// The unique ID of the plan.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The id of the satellite to be tracked in the plan.
	SatelliteId string `protobuf:"bytes,2,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The organization name of the satellite to be tracked in the plan.
	SatelliteOrganizationName string `protobuf:"bytes,17,opt,name=satellite_organization_name,json=satelliteOrganizationName,proto3" json:"satellite_organization_name,omitempty"`
	// The status of this plan.
	Status Plan_Status `protobuf:"varint,3,opt,name=status,proto3,enum=stellarstation.api.v1.Plan_Status" json:"status,omitempty"`
	// The start of the time window reserved for the plan. This value does not change over time.
	StartTime *timestamp.Timestamp `protobuf:"bytes,14,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The end of the time window reserved for the plan. This value does not change over time.
	EndTime *timestamp.Timestamp `protobuf:"bytes,15,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// The time of Acquisition of Signal (AOS) between the ground station and satellite in this plan.
	//
	// This value is never before 'start_time'. It may change over time (for example, if updated
	// TLE becomes available).
	AosTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=aos_time,json=aosTime,proto3" json:"aos_time,omitempty"`
	// The time of Loss of Signal (LOS) between the ground station and satellite in this plan.
	//
	// This value is never after 'end_time'. It may change over time (for example, if updated
	// TLE becomes available).
	LosTime *timestamp.Timestamp `protobuf:"bytes,5,opt,name=los_time,json=losTime,proto3" json:"los_time,omitempty"`
	// The latitude, in degrees, of the ground station's location.
	GroundStationLatitude float64 `protobuf:"fixed64,6,opt,name=ground_station_latitude,json=groundStationLatitude,proto3" json:"ground_station_latitude,omitempty"`
	// The longitude, in degrees, of the ground station's location.
	GroundStationLongitude float64 `protobuf:"fixed64,7,opt,name=ground_station_longitude,json=groundStationLongitude,proto3" json:"ground_station_longitude,omitempty"`
	// The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
	// See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	GroundStationCountryCode string `protobuf:"bytes,8,opt,name=ground_station_country_code,json=groundStationCountryCode,proto3" json:"ground_station_country_code,omitempty"`
	// The organization name of the ground station.
	GroundStationOrganizationName string `protobuf:"bytes,18,opt,name=ground_station_organization_name,json=groundStationOrganizationName,proto3" json:"ground_station_organization_name,omitempty"`
	// The ID of the ground station.
	GroundStationId string `protobuf:"bytes,20,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// The max elevation during the plan, in degrees.
	MaxElevationDegrees float64 `protobuf:"fixed64,9,opt,name=max_elevation_degrees,json=maxElevationDegrees,proto3" json:"max_elevation_degrees,omitempty"`
	// The time of the max elevation during the plan.
	MaxElevationTime *timestamp.Timestamp `protobuf:"bytes,10,opt,name=max_elevation_time,json=maxElevationTime,proto3" json:"max_elevation_time,omitempty"`
	// Metadata for telemetry received during the pass. Only populated when the pass has completed
	// successfully and data processing is complete.
	TelemetryMetadata []*TelemetryMetadata `protobuf:"bytes,13,rep,name=telemetry_metadata,json=telemetryMetadata,proto3" json:"telemetry_metadata,omitempty"`
	// The channel set used to reserve this plan.
	ChannelSet *ChannelSet `protobuf:"bytes,16,opt,name=channel_set,json=channelSet,proto3" json:"channel_set,omitempty"`
	// The price per minute (USD) for this plan set by the ground station owner at the time of reservation.
	UnitPrice float64 `protobuf:"fixed64,19,opt,name=unit_price,json=unitPrice,proto3" json:"unit_price,omitempty"`
	// The priority of the plan.
	Priority             Priority `protobuf:"varint,21,opt,name=priority,proto3,enum=stellarstation.api.v1.Priority" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{19}
}

func (m *Plan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Plan.Unmarshal(m, b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return xxx_messageInfo_Plan.Size(m)
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Plan) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *Plan) GetSatelliteOrganizationName() string {
	if m != nil {
		return m.SatelliteOrganizationName
	}
	return ""
}

func (m *Plan) GetStatus() Plan_Status {
	if m != nil {
		return m.Status
	}
	return Plan_RESERVED
}

func (m *Plan) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Plan) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Plan) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Plan) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Plan) GetGroundStationLatitude() float64 {
	if m != nil {
		return m.GroundStationLatitude
	}
	return 0
}

func (m *Plan) GetGroundStationLongitude() float64 {
	if m != nil {
		return m.GroundStationLongitude
	}
	return 0
}

func (m *Plan) GetGroundStationCountryCode() string {
	if m != nil {
		return m.GroundStationCountryCode
	}
	return ""
}

func (m *Plan) GetGroundStationOrganizationName() string {
	if m != nil {
		return m.GroundStationOrganizationName
	}
	return ""
}

func (m *Plan) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *Plan) GetMaxElevationDegrees() float64 {
	if m != nil {
		return m.MaxElevationDegrees
	}
	return 0
}

func (m *Plan) GetMaxElevationTime() *timestamp.Timestamp {
	if m != nil {
		return m.MaxElevationTime
	}
	return nil
}

func (m *Plan) GetTelemetryMetadata() []*TelemetryMetadata {
	if m != nil {
		return m.TelemetryMetadata
	}
	return nil
}

func (m *Plan) GetChannelSet() *ChannelSet {
	if m != nil {
		return m.ChannelSet
	}
	return nil
}

func (m *Plan) GetUnitPrice() float64 {
	if m != nil {
		return m.UnitPrice
	}
	return 0
}

func (m *Plan) GetPriority() Priority {
	if m != nil {
		return m.Priority
	}
	return Priority_LOW
}

// Request for the 'AddTle' method.
type AddTleRequest struct {
	// The ID of the satellite to add TLE for. The ID can be found on the StellarStation
	// Console page for the satellite.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The TLE to be added.
	Tle                  *orbit.Tle `protobuf:"bytes,2,opt,name=tle,proto3" json:"tle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AddTleRequest) Reset()         { *m = AddTleRequest{} }
func (m *AddTleRequest) String() string { return proto.CompactTextString(m) }
func (*AddTleRequest) ProtoMessage()    {}
func (*AddTleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{20}
}

func (m *AddTleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddTleRequest.Unmarshal(m, b)
}
func (m *AddTleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddTleRequest.Marshal(b, m, deterministic)
}
func (m *AddTleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTleRequest.Merge(m, src)
}
func (m *AddTleRequest) XXX_Size() int {
	return xxx_messageInfo_AddTleRequest.Size(m)
}
func (m *AddTleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTleRequest proto.InternalMessageInfo

func (m *AddTleRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *AddTleRequest) GetTle() *orbit.Tle {
	if m != nil {
		return m.Tle
	}
	return nil
}

// Response for the `AddTle` method.
type AddTleResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddTleResponse) Reset()         { *m = AddTleResponse{} }
func (m *AddTleResponse) String() string { return proto.CompactTextString(m) }
func (*AddTleResponse) ProtoMessage()    {}
func (*AddTleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{21}
}

func (m *AddTleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddTleResponse.Unmarshal(m, b)
}
func (m *AddTleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddTleResponse.Marshal(b, m, deterministic)
}
func (m *AddTleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTleResponse.Merge(m, src)
}
func (m *AddTleResponse) XXX_Size() int {
	return xxx_messageInfo_AddTleResponse.Size(m)
}
func (m *AddTleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTleResponse proto.InternalMessageInfo

// Request for the 'GetTle' method.
type GetTleRequest struct {
	// The ID of the satellite for which to fetch TLE. The ID can be found on the StellarStation
	// Console page for the satellite.
	SatelliteId          string   `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTleRequest) Reset()         { *m = GetTleRequest{} }
func (m *GetTleRequest) String() string { return proto.CompactTextString(m) }
func (*GetTleRequest) ProtoMessage()    {}
func (*GetTleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{22}
}

func (m *GetTleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTleRequest.Unmarshal(m, b)
}
func (m *GetTleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTleRequest.Marshal(b, m, deterministic)
}
func (m *GetTleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTleRequest.Merge(m, src)
}
func (m *GetTleRequest) XXX_Size() int {
	return xxx_messageInfo_GetTleRequest.Size(m)
}
func (m *GetTleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTleRequest proto.InternalMessageInfo

func (m *GetTleRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

// Response for the 'GetTle' method.
type GetTleResponse struct {
	// The TLE for the given satellite.
	Tle                  *orbit.Tle `protobuf:"bytes,1,opt,name=tle,proto3" json:"tle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetTleResponse) Reset()         { *m = GetTleResponse{} }
func (m *GetTleResponse) String() string { return proto.CompactTextString(m) }
func (*GetTleResponse) ProtoMessage()    {}
func (*GetTleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{23}
}

func (m *GetTleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTleResponse.Unmarshal(m, b)
}
func (m *GetTleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTleResponse.Marshal(b, m, deterministic)
}
func (m *GetTleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTleResponse.Merge(m, src)
}
func (m *GetTleResponse) XXX_Size() int {
	return xxx_messageInfo_GetTleResponse.Size(m)
}
func (m *GetTleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTleResponse proto.InternalMessageInfo

func (m *GetTleResponse) GetTle() *orbit.Tle {
	if m != nil {
		return m.Tle
	}
	return nil
}

// Request for the `SetTleSource` method.
type SetTleSourceRequest struct {
	// The ID of the satellite to set the TLE for.
	//
	// Required.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The source of the TLE the satellite will use for pass calculations.
	//
	// Required.
	Source               SetTleSourceRequest_Source `protobuf:"varint,2,opt,name=source,proto3,enum=stellarstation.api.v1.SetTleSourceRequest_Source" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SetTleSourceRequest) Reset()         { *m = SetTleSourceRequest{} }
func (m *SetTleSourceRequest) String() string { return proto.CompactTextString(m) }
func (*SetTleSourceRequest) ProtoMessage()    {}
func (*SetTleSourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{24}
}

func (m *SetTleSourceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetTleSourceRequest.Unmarshal(m, b)
}
func (m *SetTleSourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetTleSourceRequest.Marshal(b, m, deterministic)
}
func (m *SetTleSourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTleSourceRequest.Merge(m, src)
}
func (m *SetTleSourceRequest) XXX_Size() int {
	return xxx_messageInfo_SetTleSourceRequest.Size(m)
}
func (m *SetTleSourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTleSourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetTleSourceRequest proto.InternalMessageInfo

func (m *SetTleSourceRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *SetTleSourceRequest) GetSource() SetTleSourceRequest_Source {
	if m != nil {
		return m.Source
	}
	return SetTleSourceRequest_UNKNOWN
}

// Response for the `SetTleSource` method.
type SetTleSourceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetTleSourceResponse) Reset()         { *m = SetTleSourceResponse{} }
func (m *SetTleSourceResponse) String() string { return proto.CompactTextString(m) }
func (*SetTleSourceResponse) ProtoMessage()    {}
func (*SetTleSourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{25}
}

func (m *SetTleSourceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetTleSourceResponse.Unmarshal(m, b)
}
func (m *SetTleSourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetTleSourceResponse.Marshal(b, m, deterministic)
}
func (m *SetTleSourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTleSourceResponse.Merge(m, src)
}
func (m *SetTleSourceResponse) XXX_Size() int {
	return xxx_messageInfo_SetTleSourceResponse.Size(m)
}
func (m *SetTleSourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTleSourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetTleSourceResponse proto.InternalMessageInfo

// Message to be nested inside of a SetPlanMetadataRequest message in order to
// get around the limitation of protobuf maps not allowing repeated values.
type PlanMetadata struct {
	Metadata             map[string]*PlanMetadata_Metadata `protobuf:"bytes,2,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *PlanMetadata) Reset()         { *m = PlanMetadata{} }
func (m *PlanMetadata) String() string { return proto.CompactTextString(m) }
func (*PlanMetadata) ProtoMessage()    {}
func (*PlanMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{26}
}

func (m *PlanMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlanMetadata.Unmarshal(m, b)
}
func (m *PlanMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlanMetadata.Marshal(b, m, deterministic)
}
func (m *PlanMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanMetadata.Merge(m, src)
}
func (m *PlanMetadata) XXX_Size() int {
	return xxx_messageInfo_PlanMetadata.Size(m)
}
func (m *PlanMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_PlanMetadata proto.InternalMessageInfo

func (m *PlanMetadata) GetMetadata() map[string]*PlanMetadata_Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type PlanMetadata_Metadata struct {
	Data                 []string `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlanMetadata_Metadata) Reset()         { *m = PlanMetadata_Metadata{} }
func (m *PlanMetadata_Metadata) String() string { return proto.CompactTextString(m) }
func (*PlanMetadata_Metadata) ProtoMessage()    {}
func (*PlanMetadata_Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{26, 0}
}

func (m *PlanMetadata_Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlanMetadata_Metadata.Unmarshal(m, b)
}
func (m *PlanMetadata_Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlanMetadata_Metadata.Marshal(b, m, deterministic)
}
func (m *PlanMetadata_Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanMetadata_Metadata.Merge(m, src)
}
func (m *PlanMetadata_Metadata) XXX_Size() int {
	return xxx_messageInfo_PlanMetadata_Metadata.Size(m)
}
func (m *PlanMetadata_Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanMetadata_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_PlanMetadata_Metadata proto.InternalMessageInfo

func (m *PlanMetadata_Metadata) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request for the `SetPlanMetadata` method.
type SetPlanMetadataRequest struct {
	// The ID of the plan to set the metadata for.
	//
	// Required.
	PlanId string `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The metadata to set.
	Metadata             *PlanMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SetPlanMetadataRequest) Reset()         { *m = SetPlanMetadataRequest{} }
func (m *SetPlanMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*SetPlanMetadataRequest) ProtoMessage()    {}
func (*SetPlanMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{27}
}

func (m *SetPlanMetadataRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetPlanMetadataRequest.Unmarshal(m, b)
}
func (m *SetPlanMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetPlanMetadataRequest.Marshal(b, m, deterministic)
}
func (m *SetPlanMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetPlanMetadataRequest.Merge(m, src)
}
func (m *SetPlanMetadataRequest) XXX_Size() int {
	return xxx_messageInfo_SetPlanMetadataRequest.Size(m)
}
func (m *SetPlanMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetPlanMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetPlanMetadataRequest proto.InternalMessageInfo

func (m *SetPlanMetadataRequest) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *SetPlanMetadataRequest) GetMetadata() *PlanMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Response for the `SetPlanMetadata` method.
type SetPlanMetadataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetPlanMetadataResponse) Reset()         { *m = SetPlanMetadataResponse{} }
func (m *SetPlanMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*SetPlanMetadataResponse) ProtoMessage()    {}
func (*SetPlanMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_748aaec63a216ae0, []int{28}
}

func (m *SetPlanMetadataResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetPlanMetadataResponse.Unmarshal(m, b)
}
func (m *SetPlanMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetPlanMetadataResponse.Marshal(b, m, deterministic)
}
func (m *SetPlanMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetPlanMetadataResponse.Merge(m, src)
}
func (m *SetPlanMetadataResponse) XXX_Size() int {
	return xxx_messageInfo_SetPlanMetadataResponse.Size(m)
}
func (m *SetPlanMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetPlanMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetPlanMetadataResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("stellarstation.api.v1.Priority", Priority_name, Priority_value)
	proto.RegisterEnum("stellarstation.api.v1.TelemetryMetadata_DataType", TelemetryMetadata_DataType_name, TelemetryMetadata_DataType_value)
	proto.RegisterEnum("stellarstation.api.v1.Plan_Status", Plan_Status_name, Plan_Status_value)
	proto.RegisterEnum("stellarstation.api.v1.SetTleSourceRequest_Source", SetTleSourceRequest_Source_name, SetTleSourceRequest_Source_value)
	proto.RegisterType((*SatelliteStreamRequest)(nil), "stellarstation.api.v1.SatelliteStreamRequest")
	proto.RegisterType((*SendSatelliteCommandsRequest)(nil), "stellarstation.api.v1.SendSatelliteCommandsRequest")
	proto.RegisterType((*GroundStationConfigurationRequest)(nil), "stellarstation.api.v1.GroundStationConfigurationRequest")
	proto.RegisterType((*ReceiveTelemetryAck)(nil), "stellarstation.api.v1.ReceiveTelemetryAck")
	proto.RegisterType((*TransmitterConfigurationRequest)(nil), "stellarstation.api.v1.TransmitterConfigurationRequest")
	proto.RegisterType((*ReceiverConfigurationRequest)(nil), "stellarstation.api.v1.ReceiverConfigurationRequest")
	proto.RegisterType((*SatelliteStreamResponse)(nil), "stellarstation.api.v1.SatelliteStreamResponse")
	proto.RegisterType((*ReceiveTelemetryResponse)(nil), "stellarstation.api.v1.ReceiveTelemetryResponse")
	proto.RegisterType((*CancelPlanRequest)(nil), "stellarstation.api.v1.CancelPlanRequest")
	proto.RegisterType((*CancelPlanResponse)(nil), "stellarstation.api.v1.CancelPlanResponse")
	proto.RegisterType((*ListUpcomingAvailablePassesRequest)(nil), "stellarstation.api.v1.ListUpcomingAvailablePassesRequest")
	proto.RegisterType((*ListUpcomingAvailablePassesResponse)(nil), "stellarstation.api.v1.ListUpcomingAvailablePassesResponse")
	proto.RegisterType((*ReservePassRequest)(nil), "stellarstation.api.v1.ReservePassRequest")
	proto.RegisterType((*ReservePassResponse)(nil), "stellarstation.api.v1.ReservePassResponse")
	proto.RegisterType((*ListPlansRequest)(nil), "stellarstation.api.v1.ListPlansRequest")
	proto.RegisterType((*ListPlansResponse)(nil), "stellarstation.api.v1.ListPlansResponse")
	proto.RegisterType((*ChannelSet)(nil), "stellarstation.api.v1.ChannelSet")
	proto.RegisterType((*Pass)(nil), "stellarstation.api.v1.Pass")
	proto.RegisterType((*Pass_ChannelSetToken)(nil), "stellarstation.api.v1.Pass.ChannelSetToken")
	proto.RegisterType((*TelemetryMetadata)(nil), "stellarstation.api.v1.TelemetryMetadata")
	proto.RegisterType((*Plan)(nil), "stellarstation.api.v1.Plan")
	proto.RegisterType((*AddTleRequest)(nil), "stellarstation.api.v1.AddTleRequest")
	proto.RegisterType((*AddTleResponse)(nil), "stellarstation.api.v1.AddTleResponse")
	proto.RegisterType((*GetTleRequest)(nil), "stellarstation.api.v1.GetTleRequest")
	proto.RegisterType((*GetTleResponse)(nil), "stellarstation.api.v1.GetTleResponse")
	proto.RegisterType((*SetTleSourceRequest)(nil), "stellarstation.api.v1.SetTleSourceRequest")
	proto.RegisterType((*SetTleSourceResponse)(nil), "stellarstation.api.v1.SetTleSourceResponse")
	proto.RegisterType((*PlanMetadata)(nil), "stellarstation.api.v1.PlanMetadata")
	proto.RegisterMapType((map[string]*PlanMetadata_Metadata)(nil), "stellarstation.api.v1.PlanMetadata.MetadataEntry")
	proto.RegisterType((*PlanMetadata_Metadata)(nil), "stellarstation.api.v1.PlanMetadata.Metadata")
	proto.RegisterType((*SetPlanMetadataRequest)(nil), "stellarstation.api.v1.SetPlanMetadataRequest")
	proto.RegisterType((*SetPlanMetadataResponse)(nil), "stellarstation.api.v1.SetPlanMetadataResponse")
}

func init() {
	proto.RegisterFile("stellarstation/api/v1/stellarstation.proto", fileDescriptor_748aaec63a216ae0)
}

var fileDescriptor_748aaec63a216ae0 = []byte{
	// 2257 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x4b, 0x73, 0x1b, 0x4b,
	0x15, 0xf6, 0x48, 0xb2, 0x1e, 0x47, 0x7e, 0xc8, 0xed, 0x3c, 0x74, 0xe5, 0x3c, 0x9c, 0x49, 0x6e,
	0x5d, 0xc7, 0xc9, 0x95, 0x89, 0x6e, 0xe5, 0x92, 0x1b, 0x8a, 0x50, 0xb2, 0xa4, 0xd8, 0x02, 0xbf,
	0x18, 0xd9, 0x09, 0xc5, 0x22, 0xaa, 0xf6, 0x4c, 0x4b, 0x77, 0xca, 0xa3, 0x99, 0x61, 0xa6, 0xe5,
	0xc4, 0x14, 0xc5, 0x82, 0x05, 0x1b, 0x76, 0x14, 0x2c, 0xd8, 0x50, 0x45, 0xb1, 0x81, 0x25, 0x7f,
	0x81, 0x9f, 0xc0, 0x92, 0x5f, 0x40, 0x15, 0x7f, 0x81, 0x05, 0xd5, 0x8f, 0x19, 0x8d, 0x1e, 0x23,
	0xc9, 0x86, 0x8d, 0x6a, 0xe6, 0xf4, 0xf9, 0xce, 0x39, 0xdd, 0x7d, 0xce, 0xd7, 0xa7, 0x47, 0xb0,
	0xed, 0x53, 0x62, 0x59, 0xd8, 0xf3, 0x29, 0xa6, 0xa6, 0x63, 0xef, 0x60, 0xd7, 0xdc, 0xb9, 0x7c,
	0xb1, 0x33, 0x2c, 0x2d, 0xbb, 0x9e, 0x43, 0x1d, 0x74, 0x7b, 0x44, 0x8a, 0x5d, 0xb3, 0x7c, 0xf9,
	0xa2, 0xf4, 0xb0, 0xeb, 0x38, 0x5d, 0x8b, 0xec, 0x70, 0xa5, 0xf3, 0x7e, 0x67, 0x87, 0x9a, 0x3d,
	0xe2, 0x53, 0xdc, 0x73, 0x05, 0xae, 0xf4, 0x60, 0x54, 0xe1, 0xa3, 0x87, 0x5d, 0x97, 0x78, 0xbe,
	0x1c, 0xff, 0x62, 0x72, 0x0c, 0x8e, 0x77, 0x6e, 0x52, 0xf1, 0x3b, 0x5d, 0xd1, 0xc3, 0x86, 0xe9,
	0x88, 0x5f, 0xa9, 0xf8, 0xf9, 0x64, 0x45, 0xea, 0x61, 0xdb, 0x77, 0x1d, 0x4f, 0xda, 0x53, 0xff,
	0xbd, 0x08, 0x77, 0x5a, 0x98, 0xa9, 0x9a, 0x94, 0xb4, 0xa8, 0x47, 0x70, 0x4f, 0x23, 0x3f, 0xeb,
	0x13, 0x9f, 0xa2, 0x47, 0xb0, 0xe4, 0x07, 0x23, 0x6d, 0xd3, 0x28, 0x2a, 0x9b, 0xca, 0x56, 0x4e,
	0xcb, 0x87, 0xb2, 0xa6, 0x81, 0xee, 0x42, 0xc6, 0xb5, 0xb0, 0xcd, 0x46, 0xf3, 0x7c, 0x34, 0xcd,
	0x5e, 0x9b, 0x06, 0xda, 0x80, 0x9c, 0xcf, 0x8d, 0xb1, 0xa1, 0x04, 0x1f, 0xca, 0x0a, 0x41, 0xd3,
	0x40, 0x8f, 0x61, 0x99, 0xd8, 0xf8, 0xdc, 0x22, 0x6d, 0x72, 0x49, 0x6c, 0xea, 0x17, 0x17, 0x37,
	0x95, 0xad, 0xac, 0xb6, 0x24, 0x84, 0x0d, 0x2e, 0x43, 0xf7, 0x01, 0x3c, 0x11, 0x08, 0x33, 0x91,
	0xe6, 0x26, 0x72, 0x52, 0xd2, 0x34, 0xd0, 0x2f, 0xe0, 0xa1, 0x4f, 0x6c, 0xa3, 0x3d, 0x88, 0x50,
	0x77, 0x7a, 0x3d, 0x6c, 0x1b, 0x7e, 0x5b, 0x2a, 0x15, 0x93, 0x9b, 0xca, 0x56, 0xbe, 0xf2, 0x55,
	0x79, 0xe2, 0x96, 0x95, 0x5b, 0xc4, 0x36, 0xc2, 0x89, 0xd7, 0x24, 0x56, 0x4e, 0x7d, 0x7f, 0x41,
	0xbb, 0xe7, 0x4f, 0x19, 0x47, 0xbf, 0x51, 0xe0, 0x49, 0xd7, 0x73, 0xfa, 0x2c, 0x00, 0x61, 0xb6,
	0xad, 0x3b, 0x76, 0xc7, 0xec, 0xf6, 0x3d, 0xf1, 0x16, 0xc4, 0x90, 0xe1, 0x31, 0xbc, 0x8a, 0x89,
	0x61, 0x8f, 0x9b, 0x68, 0x09, 0x61, 0x2d, 0x6a, 0x60, 0x10, 0xc8, 0xa3, 0xee, 0x2c, 0x25, 0x74,
	0x0e, 0x77, 0x28, 0xb1, 0x48, 0x8f, 0x50, 0xef, 0xaa, 0xed, 0x11, 0x9d, 0x98, 0x97, 0xc4, 0x68,
	0x63, 0xfd, 0xa2, 0x98, 0xe3, 0xee, 0xb7, 0x63, 0xdc, 0x6b, 0x42, 0xf5, 0x34, 0xc0, 0x56, 0xf5,
	0x8b, 0xfd, 0x05, 0xed, 0x56, 0x68, 0x4b, 0x8e, 0x1b, 0x55, 0xfd, 0x02, 0x35, 0xa1, 0x80, 0x75,
	0x9d, 0xb8, 0x94, 0x18, 0xed, 0x8e, 0x87, 0x7b, 0xa6, 0xdd, 0x2d, 0xa6, 0x36, 0x93, 0x5b, 0x2b,
	0x95, 0x07, 0x31, 0xd6, 0xdf, 0x0a, 0x2d, 0x6d, 0x35, 0xc0, 0x49, 0x01, 0x7a, 0x03, 0xf7, 0x3c,
	0xe2, 0xf7, 0x7b, 0xa4, 0x2d, 0x53, 0xa4, 0x47, 0x7c, 0x1f, 0x77, 0x09, 0x8b, 0x98, 0xed, 0x75,
	0x96, 0xef, 0x75, 0x51, 0xe8, 0x88, 0x94, 0x3c, 0x14, 0x1a, 0x55, 0xfd, 0xa2, 0x69, 0xa0, 0x32,
	0xac, 0xcb, 0xf4, 0xe9, 0x58, 0xce, 0x47, 0xb6, 0xf0, 0xd4, 0x73, 0xac, 0x22, 0xf0, 0x24, 0x5a,
	0x13, 0x43, 0x6f, 0x2d, 0xe7, 0x63, 0x4d, 0x0c, 0xec, 0xe6, 0x20, 0x23, 0x57, 0x4a, 0xfd, 0x00,
	0xf7, 0xa6, 0xed, 0x3b, 0x2a, 0x42, 0x46, 0xa6, 0x51, 0x31, 0xb1, 0x99, 0xdc, 0x5a, 0xd2, 0x82,
	0x57, 0xf4, 0x04, 0x56, 0xf4, 0x6f, 0xb1, 0x6d, 0x13, 0xab, 0xed, 0x13, 0x9e, 0x92, 0x49, 0x1e,
	0xe6, 0x92, 0x94, 0xb6, 0x08, 0x6d, 0x1a, 0xea, 0x9f, 0x13, 0xf0, 0x68, 0xe6, 0xa6, 0xa2, 0x5f,
	0x29, 0xf0, 0x88, 0xd7, 0x61, 0xcf, 0xa4, 0x94, 0x78, 0x31, 0xa9, 0xa3, 0xf0, 0xbd, 0xfb, 0x3a,
	0x66, 0x75, 0x4f, 0x07, 0xf8, 0x49, 0x3e, 0xb4, 0x87, 0x74, 0xba, 0x02, 0xba, 0x82, 0x07, 0x32,
	0x55, 0xe2, 0x02, 0x48, 0x4c, 0xad, 0x1f, 0x99, 0x1c, 0x93, 0xbd, 0xdf, 0xf3, 0xa6, 0x8c, 0xaa,
	0xbf, 0x56, 0x60, 0x7d, 0x42, 0xee, 0xb1, 0x35, 0x1e, 0x49, 0x05, 0x41, 0x39, 0x4b, 0xbd, 0xe8,
	0xf6, 0x37, 0x01, 0x85, 0x39, 0x1e, 0xd2, 0xac, 0x0c, 0xb6, 0x54, 0x16, 0x3c, 0x5b, 0x0e, 0x78,
	0xb6, 0x7c, 0x1a, 0x68, 0x68, 0x6b, 0x01, 0x2a, 0x14, 0xa9, 0x7f, 0x4f, 0xc2, 0xc3, 0x19, 0x0b,
	0x89, 0xaa, 0xb0, 0x22, 0xb3, 0x4d, 0xc7, 0x9e, 0x67, 0x12, 0x4f, 0x6e, 0xcc, 0xb8, 0xab, 0x5d,
	0xc7, 0xb1, 0xde, 0x61, 0xab, 0x4f, 0x34, 0x49, 0x6f, 0x35, 0x01, 0x40, 0x07, 0x70, 0x4b, 0x9a,
	0x30, 0x3b, 0xed, 0x9e, 0x63, 0xf4, 0x2d, 0xee, 0x21, 0x36, 0xe6, 0x81, 0x21, 0x24, 0x70, 0xcd,
	0xce, 0x61, 0x88, 0x42, 0x3f, 0x0c, 0xd3, 0xdf, 0x34, 0x2c, 0xd2, 0x76, 0x31, 0x0b, 0xdd, 0x96,
	0x6c, 0x37, 0xcd, 0x98, 0x2c, 0x8d, 0xa6, 0x61, 0x91, 0x13, 0x01, 0x42, 0xbb, 0xb0, 0x3a, 0x88,
	0xcc, 0xff, 0x48, 0x88, 0x5b, 0x4c, 0xcd, 0x3b, 0xbb, 0x66, 0xa7, 0xc5, 0x00, 0xe8, 0x25, 0x64,
	0xce, 0x4d, 0xea, 0x61, 0x4a, 0x38, 0x8f, 0xe7, 0x2b, 0x1b, 0x63, 0xd8, 0xb7, 0x96, 0x83, 0xa9,
	0x00, 0x07, 0xba, 0x68, 0x0f, 0x20, 0xb2, 0x14, 0x8c, 0xdf, 0x57, 0x2a, 0x5f, 0xc4, 0xe4, 0x9a,
	0x38, 0xd7, 0x06, 0x6b, 0xa0, 0x45, 0xa0, 0xea, 0x1f, 0x15, 0xb8, 0x37, 0x2d, 0x19, 0xa3, 0x01,
	0x2a, 0x37, 0x0e, 0x30, 0x71, 0xf3, 0x00, 0xff, 0xa3, 0xc0, 0xdd, 0xb1, 0x23, 0xd6, 0x77, 0x1d,
	0xdb, 0x27, 0xc3, 0xe7, 0xa4, 0x32, 0x72, 0x4e, 0x3a, 0x50, 0x92, 0x39, 0xdb, 0x8e, 0xf2, 0xbb,
	0x80, 0xca, 0xec, 0xd9, 0x99, 0x93, 0xdb, 0x03, 0x8f, 0xfb, 0x0b, 0x8c, 0x59, 0x27, 0x8f, 0xa1,
	0x3d, 0x58, 0x92, 0xd1, 0xf0, 0x83, 0x59, 0xe6, 0x94, 0x1a, 0x77, 0x82, 0x72, 0x55, 0x7e, 0x5c,
	0xef, 0x2f, 0x68, 0x79, 0x7f, 0xf0, 0xba, 0x0b, 0x90, 0x0d, 0x8c, 0xaa, 0x7f, 0x50, 0xa0, 0x18,
	0x17, 0x0d, 0x7a, 0x03, 0xb9, 0x70, 0x6a, 0x45, 0x65, 0x33, 0xb9, 0x95, 0xaf, 0x6c, 0xc6, 0x31,
	0x5e, 0x08, 0x1e, 0x40, 0xa2, 0x0d, 0x48, 0x62, 0xa8, 0x01, 0x19, 0xe7, 0x92, 0xe4, 0x38, 0x97,
	0xa8, 0xcf, 0x61, 0xad, 0x86, 0x6d, 0x9d, 0x58, 0x27, 0x16, 0x0e, 0xf3, 0x25, 0x62, 0x53, 0x89,
	0xda, 0x54, 0x6f, 0x01, 0x8a, 0x6a, 0xcb, 0xf9, 0xed, 0x81, 0x7a, 0x60, 0xfa, 0xf4, 0xcc, 0xd5,
	0x1d, 0x76, 0xbc, 0x55, 0x2f, 0xb1, 0x69, 0xb1, 0xfa, 0x38, 0xc1, 0xbe, 0x4f, 0xfc, 0xf9, 0x9b,
	0x29, 0xf5, 0x1d, 0x3c, 0x9e, 0x6a, 0x48, 0x2e, 0xd9, 0x0e, 0xa4, 0x5c, 0xec, 0xfb, 0x72, 0xb5,
	0x36, 0x62, 0x56, 0x8b, 0x81, 0x34, 0xae, 0xa8, 0xfe, 0x12, 0x90, 0x46, 0x7c, 0xe2, 0x5d, 0x72,
	0x4b, 0x41, 0x40, 0xcf, 0x60, 0xcd, 0xe3, 0x52, 0x41, 0xfa, 0xd4, 0xb9, 0x20, 0xb6, 0x8c, 0xaa,
	0x10, 0x19, 0x38, 0x65, 0x72, 0xf4, 0x3d, 0xc8, 0xba, 0x9e, 0xe9, 0x78, 0x26, 0xbd, 0x92, 0x95,
	0xf0, 0x30, 0xce, 0xaf, 0x54, 0xd3, 0x42, 0x80, 0xfa, 0x96, 0xb1, 0x7d, 0xc4, 0x7f, 0x64, 0x1e,
	0x16, 0xb6, 0xc3, 0x9a, 0x8c, 0xb1, 0xc7, 0x96, 0x9a, 0x2b, 0xaa, 0x7f, 0x55, 0xa0, 0xc0, 0x16,
	0x88, 0x89, 0xae, 0xb1, 0xae, 0xe8, 0xbb, 0x90, 0xc3, 0x8e, 0xdf, 0xc6, 0x1d, 0x4a, 0xbc, 0x39,
	0xce, 0x89, 0x2c, 0x76, 0xfc, 0x2a, 0xd3, 0x45, 0xdf, 0x00, 0x30, 0xe0, 0x39, 0xe9, 0x38, 0x1e,
	0x89, 0x25, 0xd8, 0x01, 0x92, 0xb9, 0xd9, 0xe5, 0xca, 0x6a, 0x1d, 0xd6, 0x22, 0xa1, 0x8e, 0xcd,
	0x38, 0x39, 0xdf, 0x8c, 0xff, 0xa1, 0x00, 0xd4, 0xc2, 0xfe, 0x02, 0xad, 0x40, 0x22, 0x9c, 0x61,
	0xc2, 0x34, 0x10, 0x82, 0x94, 0x8d, 0x7b, 0x44, 0x66, 0x3e, 0x7f, 0x46, 0x87, 0x90, 0xee, 0xbb,
	0x96, 0x69, 0x5f, 0xc8, 0x78, 0x5f, 0x4e, 0x65, 0x2c, 0x8d, 0xfd, 0xd6, 0xc9, 0xa5, 0xa9, 0x93,
	0x61, 0xea, 0x94, 0x46, 0xd0, 0x8f, 0x21, 0x6b, 0x38, 0x1f, 0x6d, 0x6e, 0x30, 0xf5, 0xbf, 0x18,
	0x0c, 0xcd, 0xa8, 0xbf, 0x4f, 0x43, 0x8a, 0x25, 0x02, 0x7a, 0x09, 0x6c, 0xa9, 0xf9, 0x19, 0x3e,
	0xc7, 0xb6, 0x64, 0xb0, 0xe3, 0xb3, 0x37, 0x06, 0xb3, 0x02, 0xd8, 0xec, 0x3d, 0xc9, 0x58, 0x12,
	0xf6, 0x35, 0xdc, 0x1d, 0xe9, 0xd8, 0x19, 0x3d, 0xd3, 0xbe, 0x41, 0xf8, 0xc4, 0x14, 0xed, 0xf6,
	0x50, 0xa3, 0x7d, 0x20, 0x07, 0xd1, 0x2b, 0x28, 0x8e, 0xe2, 0x1c, 0xbb, 0x2b, 0x80, 0x8b, 0x1c,
	0x78, 0x67, 0x18, 0x18, 0x8c, 0xa2, 0x3d, 0xd8, 0x1c, 0x41, 0x3a, 0x5e, 0x17, 0xdb, 0xe6, 0xcf,
	0xc5, 0x0b, 0xdf, 0xba, 0x25, 0xbe, 0x75, 0xf7, 0x87, 0x2c, 0x1c, 0x47, 0xb4, 0x8e, 0xd8, 0x9e,
	0x6e, 0xc3, 0xda, 0x88, 0x21, 0xd3, 0x28, 0x2e, 0x73, 0xe4, 0xea, 0x10, 0xb2, 0x69, 0xa0, 0xef,
	0xc3, 0xc6, 0xd8, 0xc5, 0xa4, 0x6f, 0xb3, 0x83, 0x43, 0x77, 0x0c, 0x22, 0xef, 0x51, 0xc5, 0x91,
	0x3b, 0x05, 0x57, 0xa8, 0x39, 0x06, 0x41, 0x15, 0xb8, 0xdd, 0xc3, 0x9f, 0xda, 0xc4, 0x22, 0x92,
	0x17, 0x0c, 0xd2, 0xf5, 0x08, 0xf1, 0xf9, 0x45, 0x46, 0xd1, 0xd6, 0x7b, 0xf8, 0x53, 0x23, 0x18,
	0xab, 0x8b, 0x21, 0xb4, 0x0f, 0x68, 0x18, 0xc3, 0xb7, 0x26, 0x3b, 0x73, 0x6b, 0x0a, 0x51, 0x63,
	0x7c, 0x8f, 0xde, 0xc3, 0x5a, 0xb4, 0xc9, 0x16, 0x9c, 0x94, 0xe7, 0xd5, 0xf2, 0x6c, 0x0a, 0xcf,
	0x95, 0x07, 0x35, 0xc2, 0xe9, 0x4a, 0x5b, 0xd5, 0x87, 0x05, 0xa5, 0x3f, 0x29, 0xb0, 0x3a, 0xa2,
	0x84, 0x76, 0x21, 0x1f, 0x71, 0x26, 0x69, 0xe8, 0x51, 0x8c, 0x9b, 0x01, 0x58, 0x83, 0x81, 0xf1,
	0xc9, 0x24, 0x9a, 0x88, 0x21, 0xd1, 0xfb, 0x00, 0x7d, 0xdb, 0xa4, 0x6d, 0xd7, 0x33, 0x75, 0x91,
	0xba, 0x8a, 0x96, 0x63, 0x92, 0x13, 0x26, 0x50, 0xff, 0xa2, 0xc0, 0x5a, 0x78, 0xc6, 0x1d, 0x12,
	0x8a, 0x0d, 0x4c, 0x31, 0x2a, 0x40, 0xb2, 0xef, 0x59, 0xb2, 0xe8, 0xd9, 0x23, 0x3a, 0x82, 0x1c,
	0x1b, 0x69, 0xd3, 0x2b, 0x97, 0x48, 0x32, 0x7e, 0x31, 0xeb, 0xc8, 0x0c, 0xcc, 0x95, 0xeb, 0x98,
	0xe2, 0xd3, 0x2b, 0x97, 0x68, 0x59, 0x43, 0x3e, 0xa9, 0x2f, 0x20, 0x1b, 0x48, 0x51, 0x06, 0x92,
	0x5a, 0xf5, 0x7d, 0x61, 0x01, 0xad, 0x42, 0xbe, 0xde, 0x38, 0x3c, 0xae, 0x9f, 0x1d, 0x54, 0x4f,
	0x1b, 0xf5, 0x82, 0x82, 0xf2, 0x90, 0xa9, 0x37, 0x6a, 0xc7, 0xf5, 0x46, 0xbd, 0x90, 0x50, 0x7f,
	0x9b, 0x83, 0x14, 0xa3, 0xa9, 0x31, 0x46, 0x1a, 0x65, 0xe3, 0xc4, 0x38, 0x1b, 0xbf, 0x81, 0x8d,
	0x81, 0xca, 0x78, 0x41, 0xac, 0x71, 0xc4, 0x67, 0xa1, 0xca, 0x58, 0x31, 0xbc, 0x86, 0x34, 0x9b,
	0x65, 0xdf, 0xe7, 0x2b, 0xb8, 0x12, 0xdb, 0x9d, 0xb0, 0xf8, 0xca, 0x2d, 0xae, 0xa9, 0x49, 0x04,
	0x23, 0x74, 0x9f, 0x62, 0x8f, 0x8a, 0x0c, 0x5d, 0x99, 0x4d, 0xe8, 0x5c, 0x3b, 0x60, 0x1d, 0x62,
	0x8b, 0x0b, 0x47, 0x71, 0x75, 0x36, 0xeb, 0x10, 0xdb, 0x08, 0x60, 0x21, 0xc7, 0xa5, 0x6e, 0xc6,
	0x71, 0x8b, 0xff, 0x17, 0x8e, 0x4b, 0xdf, 0x94, 0xe3, 0x32, 0x53, 0x39, 0x6e, 0x06, 0xdd, 0x64,
	0x67, 0xd0, 0xcd, 0x3c, 0x14, 0x89, 0x6e, 0x4c, 0x91, 0xb7, 0x26, 0x53, 0x64, 0x2c, 0xc7, 0xe5,
	0xae, 0xcb, 0x71, 0x70, 0x23, 0x8e, 0x43, 0x83, 0x66, 0xbe, 0x27, 0xeb, 0xb2, 0xb8, 0xcc, 0x49,
	0x6e, 0x6b, 0xde, 0x3a, 0xd6, 0xd6, 0xe8, 0x18, 0x53, 0x8c, 0xf0, 0x59, 0xe1, 0x26, 0x7c, 0x36,
	0x4c, 0x51, 0xeb, 0x23, 0x14, 0x35, 0xd4, 0x06, 0xde, 0xbe, 0x6e, 0x1b, 0xf8, 0x01, 0xd2, 0xa2,
	0x1c, 0xd1, 0x12, 0x64, 0xb5, 0x46, 0xab, 0xa1, 0xbd, 0x6b, 0xd4, 0x0b, 0x0b, 0x68, 0x19, 0x72,
	0x8d, 0x9f, 0x34, 0x6a, 0x67, 0xa7, 0xcd, 0xa3, 0xbd, 0x82, 0xc2, 0x5e, 0x5b, 0x67, 0xb5, 0x5a,
	0xa3, 0xc1, 0xa9, 0x06, 0x01, 0xa4, 0xdf, 0x56, 0x9b, 0x07, 0x8d, 0x7a, 0x21, 0xc9, 0x70, 0xb5,
	0xea, 0x51, 0xad, 0xc1, 0xde, 0x52, 0x68, 0x05, 0xe0, 0x44, 0x3b, 0xae, 0x35, 0x5a, 0x2d, 0x06,
	0x5c, 0x54, 0x3b, 0xb0, 0x5c, 0x35, 0x8c, 0x53, 0x8b, 0x5c, 0xa3, 0x35, 0xac, 0x40, 0x92, 0x5a,
	0x41, 0xf7, 0x11, 0x77, 0xf1, 0x10, 0x9f, 0x5f, 0x99, 0x61, 0xa6, 0xac, 0x16, 0x60, 0x25, 0xf0,
	0x23, 0x6f, 0x00, 0x15, 0x58, 0xde, 0x23, 0xf4, 0x5a, 0x9e, 0xd5, 0x3a, 0xac, 0x04, 0x18, 0xd9,
	0x1d, 0xca, 0x58, 0x94, 0xeb, 0xc4, 0xf2, 0x37, 0x05, 0xd6, 0x5b, 0xdc, 0x4c, 0xcb, 0xe9, 0x7b,
	0xfa, 0x75, 0xa6, 0xde, 0x84, 0xb4, 0xcf, 0x31, 0x33, 0xce, 0x90, 0x09, 0xe6, 0xcb, 0xf2, 0x4d,
	0x1a, 0x50, 0x9f, 0x43, 0x5a, 0x48, 0xd8, 0x29, 0x71, 0x76, 0xf4, 0xa3, 0xa3, 0xe3, 0xf7, 0x47,
	0x85, 0x05, 0x94, 0x83, 0xc5, 0xa3, 0x63, 0xad, 0xca, 0x4e, 0x0f, 0x80, 0xf4, 0x61, 0xf5, 0xe8,
	0xac, 0x7a, 0x50, 0x48, 0xa8, 0x77, 0xe0, 0xd6, 0xb0, 0x4d, 0xb9, 0x8a, 0xff, 0x52, 0x60, 0x89,
	0x91, 0x76, 0x98, 0xd0, 0x87, 0x90, 0x0d, 0xeb, 0x23, 0xc1, 0xeb, 0xe3, 0xc5, 0x14, 0xae, 0x0f,
	0x8f, 0xb8, 0xe0, 0xa1, 0xc1, 0x58, 0x46, 0x0b, 0x4d, 0x94, 0x1e, 0x40, 0x36, 0x34, 0x8d, 0x20,
	0xc5, 0xcd, 0xb2, 0x4e, 0x3c, 0xa7, 0xf1, 0xe7, 0x92, 0x09, 0xcb, 0x43, 0x50, 0x76, 0xf4, 0x5e,
	0x90, 0xab, 0xe0, 0xe8, 0xbd, 0x20, 0x57, 0x68, 0x17, 0x16, 0x2f, 0xb1, 0xd5, 0x0f, 0x12, 0xe6,
	0xf9, 0x75, 0xc2, 0xd1, 0x04, 0xf4, 0x75, 0xe2, 0x95, 0xa2, 0x7a, 0x70, 0xa7, 0x45, 0x68, 0x54,
	0x6d, 0xd6, 0xdd, 0x13, 0xfd, 0x60, 0x68, 0x31, 0x98, 0xf7, 0xc7, 0x73, 0x78, 0x1f, 0x4c, 0x5f,
	0xfd, 0x0c, 0xee, 0x8e, 0xf9, 0x14, 0x2b, 0xbf, 0xfd, 0x14, 0xb2, 0x41, 0xbd, 0xb2, 0x0e, 0xe0,
	0xe0, 0x98, 0x75, 0x00, 0x6c, 0xcb, 0x1a, 0xf5, 0xe6, 0xd9, 0x61, 0x41, 0x41, 0x59, 0x48, 0xed,
	0x37, 0xf7, 0xf6, 0x0b, 0x89, 0xca, 0x3f, 0x33, 0x70, 0xbb, 0x25, 0xdc, 0x4a, 0x42, 0x6d, 0x11,
	0x8f, 0x75, 0xfb, 0xe8, 0x03, 0xe4, 0xc2, 0x1b, 0x0f, 0x8a, 0xfb, 0x4e, 0x32, 0x7a, 0x7d, 0x2b,
	0x6d, 0xcd, 0x56, 0x94, 0xe5, 0x81, 0x01, 0x06, 0x97, 0x6f, 0x14, 0x87, 0x1b, 0xbb, 0xcd, 0x97,
	0x9e, 0xce, 0xa1, 0x29, 0x5d, 0xfc, 0x4e, 0x81, 0x8d, 0x29, 0x37, 0x70, 0xf4, 0xcd, 0x94, 0x60,
	0xa7, 0x5f, 0xff, 0x4b, 0xaf, 0x6f, 0x02, 0x95, 0x61, 0x7d, 0x82, 0xf5, 0x63, 0x97, 0xd8, 0x23,
	0x9f, 0x90, 0xd0, 0x97, 0x71, 0x05, 0x3b, 0xf1, 0xdf, 0x9c, 0x52, 0x79, 0x5e, 0x75, 0xe1, 0x75,
	0x4b, 0xf9, 0x8e, 0x82, 0x0c, 0xc8, 0x47, 0x6e, 0xee, 0xe8, 0x69, 0xec, 0xb7, 0xa6, 0xd1, 0xaf,
	0x0b, 0xa5, 0xed, 0x79, 0x54, 0xe5, 0xfc, 0xce, 0x20, 0x2d, 0x08, 0x15, 0x3d, 0x89, 0x41, 0x0d,
	0xf1, 0x7a, 0xe9, 0xf3, 0x19, 0x5a, 0x03, 0xb3, 0x82, 0x61, 0x63, 0xcd, 0x0e, 0x91, 0x76, 0xac,
	0xd9, 0x11, 0x9a, 0xee, 0xc2, 0x52, 0x94, 0xbe, 0xd0, 0xf6, 0xfc, 0xbc, 0x59, 0x7a, 0x36, 0x97,
	0xae, 0x74, 0xe4, 0xc2, 0xea, 0x48, 0xc1, 0xc6, 0x6f, 0xf9, 0x44, 0x32, 0x89, 0xdf, 0xf2, 0xc9,
	0x3c, 0xb0, 0xdb, 0x81, 0xcf, 0x74, 0xa7, 0x37, 0x19, 0xb4, 0xbb, 0xde, 0x1a, 0x12, 0x9f, 0xb0,
	0x5e, 0xe7, 0x44, 0xf9, 0x69, 0xa5, 0x6b, 0xd2, 0x6f, 0xfb, 0xe7, 0x65, 0xdd, 0xe9, 0xed, 0x98,
	0x76, 0xc7, 0x91, 0x60, 0xd3, 0xd6, 0x77, 0xba, 0xce, 0x97, 0x13, 0xff, 0x83, 0x3c, 0x4f, 0xf3,
	0x46, 0xe9, 0xab, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x9f, 0x85, 0xad, 0x0c, 0x79, 0x1d, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StellarStationServiceClient is the client API for StellarStationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StellarStationServiceClient interface {
	// Lists the plans for a particular satellite.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error)
	// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
	// executed. This action cannot be undone, but it is still possible to reserve the corresponding
	// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
	// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
	// AOS.
	//
	// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
	// for details.
	//
	// If the plan is not found, the request will return a `NOT_FOUND` error.
	//
	// If the plan has already been canceled or is less than ten minutes away from its AOS, the
	// request will return a `FAILED_PRECONDITION` error.
	//
	// If the plan is ongoing or has already finished executing, the request will return a
	// `OUT_OF_RANGE` error.
	CancelPlan(ctx context.Context, in *CancelPlanRequest, opts ...grpc.CallOption) (*CancelPlanResponse, error)
	// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
	// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
	// reserve passes in any way - it is possible for a pass that is returned by this method to be
	// unschedulable when actually trying to schedule because a conflict appeared during that time.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	ListUpcomingAvailablePasses(ctx context.Context, in *ListUpcomingAvailablePassesRequest, opts ...grpc.CallOption) (*ListUpcomingAvailablePassesResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes along
	// with associated events from this point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well. If `SatelliteStreamRequest.plan_id` is provided, only messages
	// for the specified plan will be returned.
	//
	// The first `SatelliteStreamRequest` sent on the stream is used for configuring the stream.
	// Unless otherwise specified, all configuration is taken from the first request and configuration
	// values in subsequent requests will be ignored.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error)
	// Reserves a pass for later execution as a plan. The pass must be specified by a
	// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
	// `aos_time` must be at least one hour in the future.
	//
	// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
	//
	// If the requested pass cannot be scheduled due to a conflict with existing plans or other
	// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
	// if the pass `aos_time` is less than one hour in the future.
	//
	// Note that the reservation_token may have become unreservable since it was fetched. If that's
	// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
	// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
	// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
	ReservePass(ctx context.Context, in *ReservePassRequest, opts ...grpc.CallOption) (*ReservePassResponse, error)
	// Adds TLE for a satellite.
	//
	// The TLE will be used for satellite orbit calculation until it is superseded by a newly
	// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
	// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
	//
	// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
	// - the TLE cannot be parsed
	// - the TLE norad ID does not correspond to the requested satellite.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	AddTle(ctx context.Context, in *AddTleRequest, opts ...grpc.CallOption) (*AddTleResponse, error)
	// Gets the TLE for a satellite.
	//
	// The returned TLE will be the one that has most recently been added to StellarStation and matches
	// the satellite's TLE source. This TLE is used when calculating satellite orbits.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	GetTle(ctx context.Context, in *GetTleRequest, opts ...grpc.CallOption) (*GetTleResponse, error)
	// Sets the TLE source for a satellite.
	//
	// The selected source will be used for all upcoming pass calculations for the satellite. If TLE
	// does not exist for a specific source, no passes will be generated.
	//
	// An 'INVALID_ARGUMENT' error will be returned in the following condition:
	// - no satellite_id is provided.
	// - the source provided is invalid.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	SetTleSource(ctx context.Context, in *SetTleSourceRequest, opts ...grpc.CallOption) (*SetTleSourceResponse, error)
	// Sets the metadata for a plan.
	//
	// Metadata added to a plan is available via ListPlans RPCs for both satellite and ground station
	// APIs. Because of this, it is important not to store sensitive information that the plan's
	// satellite operator and ground station operator should not have access to.
	//
	// Any metadata set with this method will overwrite existing metadata.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	SetPlanMetadata(ctx context.Context, in *SetPlanMetadataRequest, opts ...grpc.CallOption) (*SetPlanMetadataResponse, error)
}

type stellarStationServiceClient struct {
	cc *grpc.ClientConn
}

func NewStellarStationServiceClient(cc *grpc.ClientConn) StellarStationServiceClient {
	return &stellarStationServiceClient{cc}
}

func (c *stellarStationServiceClient) ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error) {
	out := new(ListPlansResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ListPlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) CancelPlan(ctx context.Context, in *CancelPlanRequest, opts ...grpc.CallOption) (*CancelPlanResponse, error) {
	out := new(CancelPlanResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/CancelPlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) ListUpcomingAvailablePasses(ctx context.Context, in *ListUpcomingAvailablePassesRequest, opts ...grpc.CallOption) (*ListUpcomingAvailablePassesResponse, error) {
	out := new(ListUpcomingAvailablePassesResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ListUpcomingAvailablePasses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StellarStationService_serviceDesc.Streams[0], "/stellarstation.api.v1.StellarStationService/OpenSatelliteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stellarStationServiceOpenSatelliteStreamClient{stream}
	return x, nil
}

type StellarStationService_OpenSatelliteStreamClient interface {
	Send(*SatelliteStreamRequest) error
	Recv() (*SatelliteStreamResponse, error)
	grpc.ClientStream
}

type stellarStationServiceOpenSatelliteStreamClient struct {
	grpc.ClientStream
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Send(m *SatelliteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Recv() (*SatelliteStreamResponse, error) {
	m := new(SatelliteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stellarStationServiceClient) ReservePass(ctx context.Context, in *ReservePassRequest, opts ...grpc.CallOption) (*ReservePassResponse, error) {
	out := new(ReservePassResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ReservePass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) AddTle(ctx context.Context, in *AddTleRequest, opts ...grpc.CallOption) (*AddTleResponse, error) {
	out := new(AddTleResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/AddTle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) GetTle(ctx context.Context, in *GetTleRequest, opts ...grpc.CallOption) (*GetTleResponse, error) {
	out := new(GetTleResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/GetTle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) SetTleSource(ctx context.Context, in *SetTleSourceRequest, opts ...grpc.CallOption) (*SetTleSourceResponse, error) {
	out := new(SetTleSourceResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/SetTleSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) SetPlanMetadata(ctx context.Context, in *SetPlanMetadataRequest, opts ...grpc.CallOption) (*SetPlanMetadataResponse, error) {
	out := new(SetPlanMetadataResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/SetPlanMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StellarStationServiceServer is the server API for StellarStationService service.
type StellarStationServiceServer interface {
	// Lists the plans for a particular satellite.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListPlans(context.Context, *ListPlansRequest) (*ListPlansResponse, error)
	// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
	// executed. This action cannot be undone, but it is still possible to reserve the corresponding
	// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
	// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
	// AOS.
	//
	// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
	// for details.
	//
	// If the plan is not found, the request will return a `NOT_FOUND` error.
	//
	// If the plan has already been canceled or is less than ten minutes away from its AOS, the
	// request will return a `FAILED_PRECONDITION` error.
	//
	// If the plan is ongoing or has already finished executing, the request will return a
	// `OUT_OF_RANGE` error.
	CancelPlan(context.Context, *CancelPlanRequest) (*CancelPlanResponse, error)
	// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
	// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
	// reserve passes in any way - it is possible for a pass that is returned by this method to be
	// unschedulable when actually trying to schedule because a conflict appeared during that time.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	ListUpcomingAvailablePasses(context.Context, *ListUpcomingAvailablePassesRequest) (*ListUpcomingAvailablePassesResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes along
	// with associated events from this point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well. If `SatelliteStreamRequest.plan_id` is provided, only messages
	// for the specified plan will be returned.
	//
	// The first `SatelliteStreamRequest` sent on the stream is used for configuring the stream.
	// Unless otherwise specified, all configuration is taken from the first request and configuration
	// values in subsequent requests will be ignored.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(StellarStationService_OpenSatelliteStreamServer) error
	// Reserves a pass for later execution as a plan. The pass must be specified by a
	// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
	// `aos_time` must be at least one hour in the future.
	//
	// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
	//
	// If the requested pass cannot be scheduled due to a conflict with existing plans or other
	// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
	// if the pass `aos_time` is less than one hour in the future.
	//
	// Note that the reservation_token may have become unreservable since it was fetched. If that's
	// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
	// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
	// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
	ReservePass(context.Context, *ReservePassRequest) (*ReservePassResponse, error)
	// Adds TLE for a satellite.
	//
	// The TLE will be used for satellite orbit calculation until it is superseded by a newly
	// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
	// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
	//
	// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
	// - the TLE cannot be parsed
	// - the TLE norad ID does not correspond to the requested satellite.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	AddTle(context.Context, *AddTleRequest) (*AddTleResponse, error)
	// Gets the TLE for a satellite.
	//
	// The returned TLE will be the one that has most recently been added to StellarStation and matches
	// the satellite's TLE source. This TLE is used when calculating satellite orbits.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	GetTle(context.Context, *GetTleRequest) (*GetTleResponse, error)
	// Sets the TLE source for a satellite.
	//
	// The selected source will be used for all upcoming pass calculations for the satellite. If TLE
	// does not exist for a specific source, no passes will be generated.
	//
	// An 'INVALID_ARGUMENT' error will be returned in the following condition:
	// - no satellite_id is provided.
	// - the source provided is invalid.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	SetTleSource(context.Context, *SetTleSourceRequest) (*SetTleSourceResponse, error)
	// Sets the metadata for a plan.
	//
	// Metadata added to a plan is available via ListPlans RPCs for both satellite and ground station
	// APIs. Because of this, it is important not to store sensitive information that the plan's
	// satellite operator and ground station operator should not have access to.
	//
	// Any metadata set with this method will overwrite existing metadata.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	SetPlanMetadata(context.Context, *SetPlanMetadataRequest) (*SetPlanMetadataResponse, error)
}

func RegisterStellarStationServiceServer(s *grpc.Server, srv StellarStationServiceServer) {
	s.RegisterService(&_StellarStationService_serviceDesc, srv)
}

func _StellarStationService_ListPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ListPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ListPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ListPlans(ctx, req.(*ListPlansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_CancelPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).CancelPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/CancelPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).CancelPlan(ctx, req.(*CancelPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_ListUpcomingAvailablePasses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUpcomingAvailablePassesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ListUpcomingAvailablePasses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ListUpcomingAvailablePasses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ListUpcomingAvailablePasses(ctx, req.(*ListUpcomingAvailablePassesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_OpenSatelliteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StellarStationServiceServer).OpenSatelliteStream(&stellarStationServiceOpenSatelliteStreamServer{stream})
}

type StellarStationService_OpenSatelliteStreamServer interface {
	Send(*SatelliteStreamResponse) error
	Recv() (*SatelliteStreamRequest, error)
	grpc.ServerStream
}

type stellarStationServiceOpenSatelliteStreamServer struct {
	grpc.ServerStream
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Send(m *SatelliteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Recv() (*SatelliteStreamRequest, error) {
	m := new(SatelliteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StellarStationService_ReservePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReservePassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ReservePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ReservePass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ReservePass(ctx, req.(*ReservePassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_AddTle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).AddTle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/AddTle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).AddTle(ctx, req.(*AddTleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_GetTle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).GetTle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/GetTle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).GetTle(ctx, req.(*GetTleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_SetTleSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTleSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).SetTleSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/SetTleSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).SetTleSource(ctx, req.(*SetTleSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_SetPlanMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPlanMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).SetPlanMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/SetPlanMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).SetPlanMetadata(ctx, req.(*SetPlanMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StellarStationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stellarstation.api.v1.StellarStationService",
	HandlerType: (*StellarStationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlans",
			Handler:    _StellarStationService_ListPlans_Handler,
		},
		{
			MethodName: "CancelPlan",
			Handler:    _StellarStationService_CancelPlan_Handler,
		},
		{
			MethodName: "ListUpcomingAvailablePasses",
			Handler:    _StellarStationService_ListUpcomingAvailablePasses_Handler,
		},
		{
			MethodName: "ReservePass",
			Handler:    _StellarStationService_ReservePass_Handler,
		},
		{
			MethodName: "AddTle",
			Handler:    _StellarStationService_AddTle_Handler,
		},
		{
			MethodName: "GetTle",
			Handler:    _StellarStationService_GetTle_Handler,
		},
		{
			MethodName: "SetTleSource",
			Handler:    _StellarStationService_SetTleSource_Handler,
		},
		{
			MethodName: "SetPlanMetadata",
			Handler:    _StellarStationService_SetPlanMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenSatelliteStream",
			Handler:       _StellarStationService_OpenSatelliteStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "stellarstation/api/v1/stellarstation.proto",
}
