// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stellarstation/api/v1/groundstation/groundstation.proto

package groundstation

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	v1 "github.com/infostellarinc/go-stellarstation/api/v1"
	common "github.com/infostellarinc/go-stellarstation/api/v1/common"
	radio "github.com/infostellarinc/go-stellarstation/api/v1/radio"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request for the `CancelPlan` method.
type CancelPlanRequest struct {
	// The id of the plan to cancel, i.e., the value of `Plan.id`.
	PlanId               string   `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelPlanRequest) Reset()         { *m = CancelPlanRequest{} }
func (m *CancelPlanRequest) String() string { return proto.CompactTextString(m) }
func (*CancelPlanRequest) ProtoMessage()    {}
func (*CancelPlanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{0}
}

func (m *CancelPlanRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelPlanRequest.Unmarshal(m, b)
}
func (m *CancelPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelPlanRequest.Marshal(b, m, deterministic)
}
func (m *CancelPlanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelPlanRequest.Merge(m, src)
}
func (m *CancelPlanRequest) XXX_Size() int {
	return xxx_messageInfo_CancelPlanRequest.Size(m)
}
func (m *CancelPlanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelPlanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelPlanRequest proto.InternalMessageInfo

func (m *CancelPlanRequest) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

// Response for the `CancelPlan` method.
type CancelPlanResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelPlanResponse) Reset()         { *m = CancelPlanResponse{} }
func (m *CancelPlanResponse) String() string { return proto.CompactTextString(m) }
func (*CancelPlanResponse) ProtoMessage()    {}
func (*CancelPlanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{1}
}

func (m *CancelPlanResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelPlanResponse.Unmarshal(m, b)
}
func (m *CancelPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelPlanResponse.Marshal(b, m, deterministic)
}
func (m *CancelPlanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelPlanResponse.Merge(m, src)
}
func (m *CancelPlanResponse) XXX_Size() int {
	return xxx_messageInfo_CancelPlanResponse.Size(m)
}
func (m *CancelPlanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelPlanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelPlanResponse proto.InternalMessageInfo

// Request for the `ListPlans` method.
type ListPlansRequest struct {
	// The ID of the ground station to list plans for. The ID can be found on the StellarStation
	// Console page for the ground station.
	GroundStationId string `protobuf:"bytes,1,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// The start time of the range of plans to list (inclusive). Only plans with an Acquisition of
	// Signal (AOS) at or after this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosAfter *timestamp.Timestamp `protobuf:"bytes,2,opt,name=aos_after,json=aosAfter,proto3" json:"aos_after,omitempty"`
	// The end time of the range of plans to list (exclusive). Only plans with an Acquisition of
	// Signal (AOS) before this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosBefore            *timestamp.Timestamp `protobuf:"bytes,3,opt,name=aos_before,json=aosBefore,proto3" json:"aos_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListPlansRequest) Reset()         { *m = ListPlansRequest{} }
func (m *ListPlansRequest) String() string { return proto.CompactTextString(m) }
func (*ListPlansRequest) ProtoMessage()    {}
func (*ListPlansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{2}
}

func (m *ListPlansRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPlansRequest.Unmarshal(m, b)
}
func (m *ListPlansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPlansRequest.Marshal(b, m, deterministic)
}
func (m *ListPlansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlansRequest.Merge(m, src)
}
func (m *ListPlansRequest) XXX_Size() int {
	return xxx_messageInfo_ListPlansRequest.Size(m)
}
func (m *ListPlansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlansRequest proto.InternalMessageInfo

func (m *ListPlansRequest) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *ListPlansRequest) GetAosAfter() *timestamp.Timestamp {
	if m != nil {
		return m.AosAfter
	}
	return nil
}

func (m *ListPlansRequest) GetAosBefore() *timestamp.Timestamp {
	if m != nil {
		return m.AosBefore
	}
	return nil
}

// A response from the `ListPlans` method.
type ListPlansResponse struct {
	// The requested list of plans for the ground station.
	Plan                 []*Plan  `protobuf:"bytes,1,rep,name=plan,proto3" json:"plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPlansResponse) Reset()         { *m = ListPlansResponse{} }
func (m *ListPlansResponse) String() string { return proto.CompactTextString(m) }
func (*ListPlansResponse) ProtoMessage()    {}
func (*ListPlansResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{3}
}

func (m *ListPlansResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPlansResponse.Unmarshal(m, b)
}
func (m *ListPlansResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPlansResponse.Marshal(b, m, deterministic)
}
func (m *ListPlansResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlansResponse.Merge(m, src)
}
func (m *ListPlansResponse) XXX_Size() int {
	return xxx_messageInfo_ListPlansResponse.Size(m)
}
func (m *ListPlansResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlansResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlansResponse proto.InternalMessageInfo

func (m *ListPlansResponse) GetPlan() []*Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

// A scheduled pass. The plan will be executed on its ground station to communicate with its satellite
// during a time range between AOS and LOS, unless explicitly cancelled.
//
// Next ID: 12
type Plan struct {
	// The ID of this plan.
	PlanId string `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The TLE for the satellite in this plan.
	Tle *Tle `protobuf:"bytes,2,opt,name=tle,proto3" json:"tle,omitempty"`
	// The start of the time window reserved for the plan.
	//
	// This timestamp does not change over time, and is set to allow sufficient time at the start
	// of a plan to allow the ground station to prepare for plan execution.
	StartTime *timestamp.Timestamp `protobuf:"bytes,7,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The end of the time window reserved for the plan.
	//
	// This timestamp does not change over time, and is set to allow sufficient time at the end
	// of a plan to allow the ground station to perform cleanup tasks after executing the plan.
	EndTime *timestamp.Timestamp `protobuf:"bytes,8,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// The time of AOS between the ground station and satellite in this plan.
	//
	// This timestamp will never be before 'start_time'. If may change over time (for example, if
	// updated TLE becomes available).
	AosTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=aos_time,json=aosTime,proto3" json:"aos_time,omitempty"`
	// The time of LOS between the ground station and satellite in this plan.
	//
	// This timestamp will never be after 'end_time'. If may change over time (for example, if
	// updated TLE becomes available).
	LosTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=los_time,json=losTime,proto3" json:"los_time,omitempty"`
	// Configuration of the radio device used for downlinking from the satellite. Ground stations will
	// need to configure reception during the plan to match this device.
	DownlinkRadioDevice *radio.RadioDeviceConfiguration `protobuf:"bytes,5,opt,name=downlink_radio_device,json=downlinkRadioDevice,proto3" json:"downlink_radio_device,omitempty"`
	// Configuration of the radio device used for uplinking to the satellite. Ground stations will
	// need to configure transmission during the plan to match this device.
	UplinkRadioDevice *radio.RadioDeviceConfiguration `protobuf:"bytes,6,opt,name=uplink_radio_device,json=uplinkRadioDevice,proto3" json:"uplink_radio_device,omitempty"`
	// Predicted coordinates of the tracked satellite for every second between AOS and LOS. This
	// information is intended for calculating device states such as rotator angles and radio
	// frequencies.
	//
	// This field is only populated for future plans.
	SatelliteCoordinates []*SatelliteCoordinates `protobuf:"bytes,9,rep,name=satellite_coordinates,json=satelliteCoordinates,proto3" json:"satellite_coordinates,omitempty"`
	// The organization name of the satellite to be tracked in the plan.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	SatelliteOrganizationName string `protobuf:"bytes,10,opt,name=satellite_organization_name,json=satelliteOrganizationName,proto3" json:"satellite_organization_name,omitempty"`
	// The organization name of the ground station.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	GroundStationOrganizationName string   `protobuf:"bytes,11,opt,name=ground_station_organization_name,json=groundStationOrganizationName,proto3" json:"ground_station_organization_name,omitempty"`
	XXX_NoUnkeyedLiteral          struct{} `json:"-"`
	XXX_unrecognized              []byte   `json:"-"`
	XXX_sizecache                 int32    `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{4}
}

func (m *Plan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Plan.Unmarshal(m, b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return xxx_messageInfo_Plan.Size(m)
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *Plan) GetTle() *Tle {
	if m != nil {
		return m.Tle
	}
	return nil
}

func (m *Plan) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Plan) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Plan) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Plan) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Plan) GetDownlinkRadioDevice() *radio.RadioDeviceConfiguration {
	if m != nil {
		return m.DownlinkRadioDevice
	}
	return nil
}

func (m *Plan) GetUplinkRadioDevice() *radio.RadioDeviceConfiguration {
	if m != nil {
		return m.UplinkRadioDevice
	}
	return nil
}

func (m *Plan) GetSatelliteCoordinates() []*SatelliteCoordinates {
	if m != nil {
		return m.SatelliteCoordinates
	}
	return nil
}

func (m *Plan) GetSatelliteOrganizationName() string {
	if m != nil {
		return m.SatelliteOrganizationName
	}
	return ""
}

func (m *Plan) GetGroundStationOrganizationName() string {
	if m != nil {
		return m.GroundStationOrganizationName
	}
	return ""
}

// Unparsed TLE data for a satellite - https://en.wikipedia.org/wiki/Two-line_element_set
type Tle struct {
	// The first line of the TLE. Not a title line.
	Line_1 string `protobuf:"bytes,1,opt,name=line_1,json=line1,proto3" json:"line_1,omitempty"`
	// The second line of the TLE.
	Line_2               string   `protobuf:"bytes,2,opt,name=line_2,json=line2,proto3" json:"line_2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tle) Reset()         { *m = Tle{} }
func (m *Tle) String() string { return proto.CompactTextString(m) }
func (*Tle) ProtoMessage()    {}
func (*Tle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{5}
}

func (m *Tle) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tle.Unmarshal(m, b)
}
func (m *Tle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tle.Marshal(b, m, deterministic)
}
func (m *Tle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tle.Merge(m, src)
}
func (m *Tle) XXX_Size() int {
	return xxx_messageInfo_Tle.Size(m)
}
func (m *Tle) XXX_DiscardUnknown() {
	xxx_messageInfo_Tle.DiscardUnknown(m)
}

var xxx_messageInfo_Tle proto.InternalMessageInfo

func (m *Tle) GetLine_1() string {
	if m != nil {
		return m.Line_1
	}
	return ""
}

func (m *Tle) GetLine_2() string {
	if m != nil {
		return m.Line_2
	}
	return ""
}

// Coordinates of a satellite observed from a ground station tracking it.
type SatelliteCoordinates struct {
	// The time which the coordinates are for.
	Time *timestamp.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	// The angle of the satellite.
	Angle *common.Angle `protobuf:"bytes,2,opt,name=angle,proto3" json:"angle,omitempty"`
	// The range rate (change rate of distance) of the satellite. You can use this value to calculate
	// Doppler shifted communication frequencies using the following formulae.
	//   uplink:
	//     shifted_freq = original_freq * (1.0 + range_rate / speed_of_light)
	//   downlink:
	//     shifted_freq = original_freq * (1.0 - range_rate / speed_of_light)
	//   where speed_of_light is 299792458.0 m/s.
	RangeRate            float64  `protobuf:"fixed64,3,opt,name=range_rate,json=rangeRate,proto3" json:"range_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SatelliteCoordinates) Reset()         { *m = SatelliteCoordinates{} }
func (m *SatelliteCoordinates) String() string { return proto.CompactTextString(m) }
func (*SatelliteCoordinates) ProtoMessage()    {}
func (*SatelliteCoordinates) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{6}
}

func (m *SatelliteCoordinates) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteCoordinates.Unmarshal(m, b)
}
func (m *SatelliteCoordinates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteCoordinates.Marshal(b, m, deterministic)
}
func (m *SatelliteCoordinates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteCoordinates.Merge(m, src)
}
func (m *SatelliteCoordinates) XXX_Size() int {
	return xxx_messageInfo_SatelliteCoordinates.Size(m)
}
func (m *SatelliteCoordinates) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteCoordinates.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteCoordinates proto.InternalMessageInfo

func (m *SatelliteCoordinates) GetTime() *timestamp.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *SatelliteCoordinates) GetAngle() *common.Angle {
	if m != nil {
		return m.Angle
	}
	return nil
}

func (m *SatelliteCoordinates) GetRangeRate() float64 {
	if m != nil {
		return m.RangeRate
	}
	return 0
}

// A time window during which a ground station is unavailable e.g. for local maintenance.
type UnavailabilityWindow struct {
	// The ID of the unavailability window.
	WindowId string `protobuf:"bytes,1,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// Start time of the unavailabilty window.
	StartTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time of the unavailability window.
	EndTime              *timestamp.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UnavailabilityWindow) Reset()         { *m = UnavailabilityWindow{} }
func (m *UnavailabilityWindow) String() string { return proto.CompactTextString(m) }
func (*UnavailabilityWindow) ProtoMessage()    {}
func (*UnavailabilityWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{7}
}

func (m *UnavailabilityWindow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnavailabilityWindow.Unmarshal(m, b)
}
func (m *UnavailabilityWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnavailabilityWindow.Marshal(b, m, deterministic)
}
func (m *UnavailabilityWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnavailabilityWindow.Merge(m, src)
}
func (m *UnavailabilityWindow) XXX_Size() int {
	return xxx_messageInfo_UnavailabilityWindow.Size(m)
}
func (m *UnavailabilityWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_UnavailabilityWindow.DiscardUnknown(m)
}

var xxx_messageInfo_UnavailabilityWindow proto.InternalMessageInfo

func (m *UnavailabilityWindow) GetWindowId() string {
	if m != nil {
		return m.WindowId
	}
	return ""
}

func (m *UnavailabilityWindow) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *UnavailabilityWindow) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// A request for a list of unavailability windows for the specified ground station that
// fall within the given time range.
type ListUnavailabilityWindowsRequest struct {
	// ID of the ground station for which to retrieve unavailability windows.
	GroundStationId string `protobuf:"bytes,1,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// Start time.
	StartTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time.
	EndTime              *timestamp.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListUnavailabilityWindowsRequest) Reset()         { *m = ListUnavailabilityWindowsRequest{} }
func (m *ListUnavailabilityWindowsRequest) String() string { return proto.CompactTextString(m) }
func (*ListUnavailabilityWindowsRequest) ProtoMessage()    {}
func (*ListUnavailabilityWindowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{8}
}

func (m *ListUnavailabilityWindowsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUnavailabilityWindowsRequest.Unmarshal(m, b)
}
func (m *ListUnavailabilityWindowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUnavailabilityWindowsRequest.Marshal(b, m, deterministic)
}
func (m *ListUnavailabilityWindowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnavailabilityWindowsRequest.Merge(m, src)
}
func (m *ListUnavailabilityWindowsRequest) XXX_Size() int {
	return xxx_messageInfo_ListUnavailabilityWindowsRequest.Size(m)
}
func (m *ListUnavailabilityWindowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnavailabilityWindowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnavailabilityWindowsRequest proto.InternalMessageInfo

func (m *ListUnavailabilityWindowsRequest) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *ListUnavailabilityWindowsRequest) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ListUnavailabilityWindowsRequest) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// A response containing unavailability windows for the requested ground station.
type ListUnavailabilityWindowsResponse struct {
	// A list of unavailability windows, sorted in ascending order of the start time.
	Window               []*UnavailabilityWindow `protobuf:"bytes,1,rep,name=window,proto3" json:"window,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ListUnavailabilityWindowsResponse) Reset()         { *m = ListUnavailabilityWindowsResponse{} }
func (m *ListUnavailabilityWindowsResponse) String() string { return proto.CompactTextString(m) }
func (*ListUnavailabilityWindowsResponse) ProtoMessage()    {}
func (*ListUnavailabilityWindowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{9}
}

func (m *ListUnavailabilityWindowsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUnavailabilityWindowsResponse.Unmarshal(m, b)
}
func (m *ListUnavailabilityWindowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUnavailabilityWindowsResponse.Marshal(b, m, deterministic)
}
func (m *ListUnavailabilityWindowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnavailabilityWindowsResponse.Merge(m, src)
}
func (m *ListUnavailabilityWindowsResponse) XXX_Size() int {
	return xxx_messageInfo_ListUnavailabilityWindowsResponse.Size(m)
}
func (m *ListUnavailabilityWindowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnavailabilityWindowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnavailabilityWindowsResponse proto.InternalMessageInfo

func (m *ListUnavailabilityWindowsResponse) GetWindow() []*UnavailabilityWindow {
	if m != nil {
		return m.Window
	}
	return nil
}

// A request for adding a new unavailability window for the specified ground station.
type AddUnavailabilityWindowRequest struct {
	// ID of the ground station to add a new unavailability window.
	GroundStationId string `protobuf:"bytes,1,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// Start time of the unavailabilty window.
	StartTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time of the unavailability window.
	EndTime              *timestamp.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AddUnavailabilityWindowRequest) Reset()         { *m = AddUnavailabilityWindowRequest{} }
func (m *AddUnavailabilityWindowRequest) String() string { return proto.CompactTextString(m) }
func (*AddUnavailabilityWindowRequest) ProtoMessage()    {}
func (*AddUnavailabilityWindowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{10}
}

func (m *AddUnavailabilityWindowRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddUnavailabilityWindowRequest.Unmarshal(m, b)
}
func (m *AddUnavailabilityWindowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddUnavailabilityWindowRequest.Marshal(b, m, deterministic)
}
func (m *AddUnavailabilityWindowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUnavailabilityWindowRequest.Merge(m, src)
}
func (m *AddUnavailabilityWindowRequest) XXX_Size() int {
	return xxx_messageInfo_AddUnavailabilityWindowRequest.Size(m)
}
func (m *AddUnavailabilityWindowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUnavailabilityWindowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddUnavailabilityWindowRequest proto.InternalMessageInfo

func (m *AddUnavailabilityWindowRequest) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *AddUnavailabilityWindowRequest) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *AddUnavailabilityWindowRequest) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// A response from the 'AddUnavailabilityWindow' method.
type AddUnavailabilityWindowResponse struct {
	// ID of the new window.
	WindowId             string   `protobuf:"bytes,1,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddUnavailabilityWindowResponse) Reset()         { *m = AddUnavailabilityWindowResponse{} }
func (m *AddUnavailabilityWindowResponse) String() string { return proto.CompactTextString(m) }
func (*AddUnavailabilityWindowResponse) ProtoMessage()    {}
func (*AddUnavailabilityWindowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{11}
}

func (m *AddUnavailabilityWindowResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddUnavailabilityWindowResponse.Unmarshal(m, b)
}
func (m *AddUnavailabilityWindowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddUnavailabilityWindowResponse.Marshal(b, m, deterministic)
}
func (m *AddUnavailabilityWindowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUnavailabilityWindowResponse.Merge(m, src)
}
func (m *AddUnavailabilityWindowResponse) XXX_Size() int {
	return xxx_messageInfo_AddUnavailabilityWindowResponse.Size(m)
}
func (m *AddUnavailabilityWindowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUnavailabilityWindowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddUnavailabilityWindowResponse proto.InternalMessageInfo

func (m *AddUnavailabilityWindowResponse) GetWindowId() string {
	if m != nil {
		return m.WindowId
	}
	return ""
}

// A request for deleting an existing unavailability window for the specified ground station.
type DeleteUnavailabilityWindowRequest struct {
	// ID of the unavailability window to delete.
	WindowId             string   `protobuf:"bytes,1,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUnavailabilityWindowRequest) Reset()         { *m = DeleteUnavailabilityWindowRequest{} }
func (m *DeleteUnavailabilityWindowRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUnavailabilityWindowRequest) ProtoMessage()    {}
func (*DeleteUnavailabilityWindowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{12}
}

func (m *DeleteUnavailabilityWindowRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteUnavailabilityWindowRequest.Unmarshal(m, b)
}
func (m *DeleteUnavailabilityWindowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteUnavailabilityWindowRequest.Marshal(b, m, deterministic)
}
func (m *DeleteUnavailabilityWindowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUnavailabilityWindowRequest.Merge(m, src)
}
func (m *DeleteUnavailabilityWindowRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteUnavailabilityWindowRequest.Size(m)
}
func (m *DeleteUnavailabilityWindowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUnavailabilityWindowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUnavailabilityWindowRequest proto.InternalMessageInfo

func (m *DeleteUnavailabilityWindowRequest) GetWindowId() string {
	if m != nil {
		return m.WindowId
	}
	return ""
}

// A response to the request for deleting an existing unavailability window.
type DeleteUnavailabilityWindowResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUnavailabilityWindowResponse) Reset()         { *m = DeleteUnavailabilityWindowResponse{} }
func (m *DeleteUnavailabilityWindowResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteUnavailabilityWindowResponse) ProtoMessage()    {}
func (*DeleteUnavailabilityWindowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{13}
}

func (m *DeleteUnavailabilityWindowResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteUnavailabilityWindowResponse.Unmarshal(m, b)
}
func (m *DeleteUnavailabilityWindowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteUnavailabilityWindowResponse.Marshal(b, m, deterministic)
}
func (m *DeleteUnavailabilityWindowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUnavailabilityWindowResponse.Merge(m, src)
}
func (m *DeleteUnavailabilityWindowResponse) XXX_Size() int {
	return xxx_messageInfo_DeleteUnavailabilityWindowResponse.Size(m)
}
func (m *DeleteUnavailabilityWindowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUnavailabilityWindowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUnavailabilityWindowResponse proto.InternalMessageInfo

// A request for the `OpenGroundStationStream` method.
type GroundStationStreamRequest struct {
	// The ID of the ground station that is opening a stream. The ID of a ground station can be found
	// on the StellarStation Console page for the ground station.
	GroundStationId string `protobuf:"bytes,1,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// A tag to identify this stream. This tag is not used semantically and is only for logging,
	// monitoring, and debugging. This does not need to be set if there will only ever be one stream
	// for a particular `ground_station_id` open at a time. If multiple streams will be open, this
	// should be set to identify the stream. Some examples include 'uplink', 'downlink', 'uhf',
	// 's-band'.
	StreamTag string `protobuf:"bytes,2,opt,name=stream_tag,json=streamTag,proto3" json:"stream_tag,omitempty"`
	// A payload to send on the ground station stream. The payload does not need to be filled on the
	// first request to `OpenGroundStationStream`.
	//
	// Types that are valid to be assigned to Request:
	//	*GroundStationStreamRequest_SatelliteTelemetry
	//	*GroundStationStreamRequest_StreamEvent
	Request              isGroundStationStreamRequest_Request `protobuf_oneof:"Request"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *GroundStationStreamRequest) Reset()         { *m = GroundStationStreamRequest{} }
func (m *GroundStationStreamRequest) String() string { return proto.CompactTextString(m) }
func (*GroundStationStreamRequest) ProtoMessage()    {}
func (*GroundStationStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{14}
}

func (m *GroundStationStreamRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroundStationStreamRequest.Unmarshal(m, b)
}
func (m *GroundStationStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroundStationStreamRequest.Marshal(b, m, deterministic)
}
func (m *GroundStationStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroundStationStreamRequest.Merge(m, src)
}
func (m *GroundStationStreamRequest) XXX_Size() int {
	return xxx_messageInfo_GroundStationStreamRequest.Size(m)
}
func (m *GroundStationStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GroundStationStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GroundStationStreamRequest proto.InternalMessageInfo

func (m *GroundStationStreamRequest) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *GroundStationStreamRequest) GetStreamTag() string {
	if m != nil {
		return m.StreamTag
	}
	return ""
}

type isGroundStationStreamRequest_Request interface {
	isGroundStationStreamRequest_Request()
}

type GroundStationStreamRequest_SatelliteTelemetry struct {
	SatelliteTelemetry *SatelliteTelemetry `protobuf:"bytes,3,opt,name=satellite_telemetry,json=satelliteTelemetry,proto3,oneof"`
}

type GroundStationStreamRequest_StreamEvent struct {
	StreamEvent *v1.StreamEvent `protobuf:"bytes,4,opt,name=stream_event,json=streamEvent,proto3,oneof"`
}

func (*GroundStationStreamRequest_SatelliteTelemetry) isGroundStationStreamRequest_Request() {}

func (*GroundStationStreamRequest_StreamEvent) isGroundStationStreamRequest_Request() {}

func (m *GroundStationStreamRequest) GetRequest() isGroundStationStreamRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *GroundStationStreamRequest) GetSatelliteTelemetry() *SatelliteTelemetry {
	if x, ok := m.GetRequest().(*GroundStationStreamRequest_SatelliteTelemetry); ok {
		return x.SatelliteTelemetry
	}
	return nil
}

func (m *GroundStationStreamRequest) GetStreamEvent() *v1.StreamEvent {
	if x, ok := m.GetRequest().(*GroundStationStreamRequest_StreamEvent); ok {
		return x.StreamEvent
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GroundStationStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GroundStationStreamRequest_SatelliteTelemetry)(nil),
		(*GroundStationStreamRequest_StreamEvent)(nil),
	}
}

// Telemetry received from a satellite to send to a satellite operator.
type SatelliteTelemetry struct {
	// The ID of the plan the telemetry is being sent for.
	PlanId string `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The telemetry being sent.
	Telemetry            *v1.Telemetry `protobuf:"bytes,2,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SatelliteTelemetry) Reset()         { *m = SatelliteTelemetry{} }
func (m *SatelliteTelemetry) String() string { return proto.CompactTextString(m) }
func (*SatelliteTelemetry) ProtoMessage()    {}
func (*SatelliteTelemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{15}
}

func (m *SatelliteTelemetry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteTelemetry.Unmarshal(m, b)
}
func (m *SatelliteTelemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteTelemetry.Marshal(b, m, deterministic)
}
func (m *SatelliteTelemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteTelemetry.Merge(m, src)
}
func (m *SatelliteTelemetry) XXX_Size() int {
	return xxx_messageInfo_SatelliteTelemetry.Size(m)
}
func (m *SatelliteTelemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteTelemetry.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteTelemetry proto.InternalMessageInfo

func (m *SatelliteTelemetry) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *SatelliteTelemetry) GetTelemetry() *v1.Telemetry {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// A response for the `OpenGroundStationStream` method. The ground station must process a response
// immediately when received on the stream.
type GroundStationStreamResponse struct {
	// The ID of the plan this response corresponds to. Unfilled if this response does not correspond
	// to a plan.
	PlanId string `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// A unique ID identifying this response. If filled, any `StreamEvent` generated when handling
	// this GroundStationStreamResponse` must have this value copied into
	// `StreamEvent.request_id`. Currently, this includes
	//
	// - Returning `CommandSentFromGroundStation` after completing transmission of the commands in a
	//   `SendSatelliteCommandsResponse`.
	ResponseId string `protobuf:"bytes,2,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	// A payload sent on the stream to be processed by the ground station. Currently only commands to
	// send to a satellite will be returned to the ground station.
	//
	// Types that are valid to be assigned to Response:
	//	*GroundStationStreamResponse_SatelliteCommands
	Response             isGroundStationStreamResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *GroundStationStreamResponse) Reset()         { *m = GroundStationStreamResponse{} }
func (m *GroundStationStreamResponse) String() string { return proto.CompactTextString(m) }
func (*GroundStationStreamResponse) ProtoMessage()    {}
func (*GroundStationStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{16}
}

func (m *GroundStationStreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroundStationStreamResponse.Unmarshal(m, b)
}
func (m *GroundStationStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroundStationStreamResponse.Marshal(b, m, deterministic)
}
func (m *GroundStationStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroundStationStreamResponse.Merge(m, src)
}
func (m *GroundStationStreamResponse) XXX_Size() int {
	return xxx_messageInfo_GroundStationStreamResponse.Size(m)
}
func (m *GroundStationStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GroundStationStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GroundStationStreamResponse proto.InternalMessageInfo

func (m *GroundStationStreamResponse) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *GroundStationStreamResponse) GetResponseId() string {
	if m != nil {
		return m.ResponseId
	}
	return ""
}

type isGroundStationStreamResponse_Response interface {
	isGroundStationStreamResponse_Response()
}

type GroundStationStreamResponse_SatelliteCommands struct {
	SatelliteCommands *SatelliteCommands `protobuf:"bytes,3,opt,name=satellite_commands,json=satelliteCommands,proto3,oneof"`
}

func (*GroundStationStreamResponse_SatelliteCommands) isGroundStationStreamResponse_Response() {}

func (m *GroundStationStreamResponse) GetResponse() isGroundStationStreamResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GroundStationStreamResponse) GetSatelliteCommands() *SatelliteCommands {
	if x, ok := m.GetResponse().(*GroundStationStreamResponse_SatelliteCommands); ok {
		return x.SatelliteCommands
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GroundStationStreamResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GroundStationStreamResponse_SatelliteCommands)(nil),
	}
}

// Command to transmit to the satellite.
type SatelliteCommands struct {
	// The command frames to send to the satellite. All commands must be transmitted in sequence
	// immediately. After all commands have been transmitted, telemetry receive must be immediately
	// enabled again.
	Command              [][]byte `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SatelliteCommands) Reset()         { *m = SatelliteCommands{} }
func (m *SatelliteCommands) String() string { return proto.CompactTextString(m) }
func (*SatelliteCommands) ProtoMessage()    {}
func (*SatelliteCommands) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bce3778e6c67798, []int{17}
}

func (m *SatelliteCommands) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteCommands.Unmarshal(m, b)
}
func (m *SatelliteCommands) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteCommands.Marshal(b, m, deterministic)
}
func (m *SatelliteCommands) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteCommands.Merge(m, src)
}
func (m *SatelliteCommands) XXX_Size() int {
	return xxx_messageInfo_SatelliteCommands.Size(m)
}
func (m *SatelliteCommands) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteCommands.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteCommands proto.InternalMessageInfo

func (m *SatelliteCommands) GetCommand() [][]byte {
	if m != nil {
		return m.Command
	}
	return nil
}

func init() {
	proto.RegisterType((*CancelPlanRequest)(nil), "stellarstation.api.v1.groundstation.CancelPlanRequest")
	proto.RegisterType((*CancelPlanResponse)(nil), "stellarstation.api.v1.groundstation.CancelPlanResponse")
	proto.RegisterType((*ListPlansRequest)(nil), "stellarstation.api.v1.groundstation.ListPlansRequest")
	proto.RegisterType((*ListPlansResponse)(nil), "stellarstation.api.v1.groundstation.ListPlansResponse")
	proto.RegisterType((*Plan)(nil), "stellarstation.api.v1.groundstation.Plan")
	proto.RegisterType((*Tle)(nil), "stellarstation.api.v1.groundstation.Tle")
	proto.RegisterType((*SatelliteCoordinates)(nil), "stellarstation.api.v1.groundstation.SatelliteCoordinates")
	proto.RegisterType((*UnavailabilityWindow)(nil), "stellarstation.api.v1.groundstation.UnavailabilityWindow")
	proto.RegisterType((*ListUnavailabilityWindowsRequest)(nil), "stellarstation.api.v1.groundstation.ListUnavailabilityWindowsRequest")
	proto.RegisterType((*ListUnavailabilityWindowsResponse)(nil), "stellarstation.api.v1.groundstation.ListUnavailabilityWindowsResponse")
	proto.RegisterType((*AddUnavailabilityWindowRequest)(nil), "stellarstation.api.v1.groundstation.AddUnavailabilityWindowRequest")
	proto.RegisterType((*AddUnavailabilityWindowResponse)(nil), "stellarstation.api.v1.groundstation.AddUnavailabilityWindowResponse")
	proto.RegisterType((*DeleteUnavailabilityWindowRequest)(nil), "stellarstation.api.v1.groundstation.DeleteUnavailabilityWindowRequest")
	proto.RegisterType((*DeleteUnavailabilityWindowResponse)(nil), "stellarstation.api.v1.groundstation.DeleteUnavailabilityWindowResponse")
	proto.RegisterType((*GroundStationStreamRequest)(nil), "stellarstation.api.v1.groundstation.GroundStationStreamRequest")
	proto.RegisterType((*SatelliteTelemetry)(nil), "stellarstation.api.v1.groundstation.SatelliteTelemetry")
	proto.RegisterType((*GroundStationStreamResponse)(nil), "stellarstation.api.v1.groundstation.GroundStationStreamResponse")
	proto.RegisterType((*SatelliteCommands)(nil), "stellarstation.api.v1.groundstation.SatelliteCommands")
}

func init() {
	proto.RegisterFile("stellarstation/api/v1/groundstation/groundstation.proto", fileDescriptor_9bce3778e6c67798)
}

var fileDescriptor_9bce3778e6c67798 = []byte{
	// 1113 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x5b, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xe6, 0x62, 0xc7, 0x27, 0x95, 0xc0, 0x93, 0x44, 0x71, 0x37, 0x0a, 0x71, 0xb7, 0xa0,
	0xa6, 0x88, 0xda, 0x24, 0x55, 0x1a, 0x05, 0x89, 0x90, 0x5b, 0x9b, 0x44, 0x42, 0x34, 0x6c, 0x82,
	0x90, 0x78, 0xb1, 0x26, 0xde, 0xc9, 0x32, 0xb0, 0x3b, 0x63, 0x76, 0xc7, 0x8e, 0x5a, 0x89, 0x07,
	0x5e, 0xf8, 0x1d, 0x7d, 0x00, 0x21, 0x21, 0xf1, 0xc2, 0x13, 0x4f, 0x88, 0x1f, 0xc0, 0x8f, 0x42,
	0x73, 0x59, 0x5f, 0xe2, 0x5d, 0x7b, 0x93, 0x48, 0x48, 0x7d, 0x71, 0x32, 0xc7, 0xe7, 0xfb, 0xce,
	0x9c, 0x6f, 0xce, 0x39, 0xb3, 0x6b, 0xd8, 0x8a, 0x05, 0x09, 0x02, 0x1c, 0xc5, 0x02, 0x0b, 0xca,
	0x59, 0x1d, 0xb7, 0x68, 0xbd, 0xb3, 0x5e, 0xf7, 0x23, 0xde, 0x66, 0x5e, 0x62, 0x1c, 0x58, 0xd5,
	0x5a, 0x11, 0x17, 0x1c, 0x3d, 0x1c, 0x04, 0xd6, 0x70, 0x8b, 0xd6, 0x3a, 0xeb, 0xb5, 0x01, 0x57,
	0x7b, 0xd5, 0xe7, 0xdc, 0x0f, 0x48, 0x5d, 0x41, 0x2e, 0xda, 0x97, 0x75, 0x41, 0x43, 0x12, 0x0b,
	0x1c, 0xb6, 0x34, 0x8b, 0xfd, 0x38, 0x3d, 0x7c, 0x93, 0x87, 0x21, 0x67, 0xe6, 0x8f, 0x71, 0x7d,
	0x94, 0xee, 0x1a, 0x61, 0x8f, 0x72, 0xfd, 0x69, 0x1c, 0x3f, 0x48, 0x77, 0x14, 0x11, 0x66, 0x71,
	0x8b, 0x47, 0x42, 0xbb, 0x39, 0x1f, 0x41, 0xf9, 0x00, 0xb3, 0x26, 0x09, 0x4e, 0x03, 0xcc, 0x5c,
	0xf2, 0x43, 0x9b, 0xc4, 0x02, 0x2d, 0x41, 0xb1, 0x15, 0x60, 0xd6, 0xa0, 0x5e, 0xc5, 0xaa, 0x5a,
	0x6b, 0x25, 0xb7, 0x20, 0x97, 0x27, 0x9e, 0xb3, 0x00, 0xa8, 0xdf, 0x3b, 0x6e, 0x71, 0x16, 0x13,
	0xe7, 0x4f, 0x0b, 0xde, 0xfd, 0x9c, 0xc6, 0x42, 0x1a, 0xe3, 0x84, 0xe3, 0x43, 0x28, 0x6b, 0x15,
	0x1a, 0x66, 0x07, 0x3d, 0xb6, 0x77, 0xf4, 0x17, 0x67, 0xda, 0x7e, 0xe2, 0xa1, 0x2d, 0x28, 0x61,
	0x1e, 0x37, 0xf0, 0xa5, 0x20, 0x51, 0x65, 0xb2, 0x6a, 0xad, 0xcd, 0x6d, 0xd8, 0x35, 0x2d, 0x5a,
	0x2d, 0x11, 0xad, 0x76, 0x9e, 0x88, 0xe6, 0xce, 0x62, 0x1e, 0xef, 0x49, 0x5f, 0xb4, 0x0d, 0x20,
	0x81, 0x17, 0xe4, 0x92, 0x47, 0xa4, 0x32, 0x35, 0x16, 0x29, 0xc3, 0xec, 0x2b, 0x67, 0xc7, 0x85,
	0x72, 0xdf, 0x9e, 0x75, 0x26, 0xe8, 0x53, 0x98, 0x96, 0x99, 0x56, 0xac, 0xea, 0xd4, 0xda, 0xdc,
	0xc6, 0xe3, 0x5a, 0x8e, 0xd3, 0xad, 0x29, 0x29, 0x14, 0xcc, 0xf9, 0xb9, 0x00, 0xd3, 0x72, 0x99,
	0x29, 0x20, 0xfa, 0x04, 0xa6, 0x44, 0x40, 0x4c, 0x8e, 0x6b, 0xb9, 0xf8, 0xcf, 0x03, 0xe2, 0x4a,
	0x90, 0x4c, 0x36, 0x16, 0x38, 0x12, 0x0d, 0x59, 0x3e, 0x95, 0xe2, 0xf8, 0x64, 0x95, 0xb7, 0x5c,
	0xa3, 0x4d, 0x98, 0x25, 0xcc, 0xd3, 0xc0, 0xd9, 0xb1, 0xc0, 0x22, 0x61, 0x5e, 0x02, 0x93, 0xf2,
	0x2a, 0xd8, 0x78, 0x71, 0x8b, 0x98, 0xc7, 0x09, 0x2c, 0x48, 0x60, 0xd3, 0xe3, 0x61, 0x81, 0x81,
	0x51, 0x58, 0xf4, 0xf8, 0x15, 0x0b, 0x28, 0xfb, 0xbe, 0xa1, 0x2a, 0xb9, 0xe1, 0x91, 0x0e, 0x6d,
	0x92, 0xca, 0x8c, 0xe2, 0xd8, 0xcc, 0x50, 0x4b, 0x17, 0xbd, 0x2b, 0x3f, 0x0f, 0x95, 0xff, 0x01,
	0x67, 0x97, 0xd4, 0x6f, 0x47, 0xca, 0xcb, 0x9d, 0x4f, 0x38, 0xfb, 0x3c, 0x10, 0x81, 0xf9, 0x76,
	0x6b, 0x38, 0x50, 0xe1, 0x2e, 0x81, 0xca, 0x9a, 0xb1, 0x3f, 0x0c, 0x83, 0xc5, 0x18, 0x4b, 0x2e,
	0x2a, 0x48, 0xa3, 0xc9, 0x79, 0xe4, 0x51, 0x86, 0x05, 0x89, 0x2b, 0x25, 0x55, 0x5f, 0xdb, 0xb9,
	0xce, 0xff, 0x2c, 0x61, 0x38, 0xe8, 0x11, 0xb8, 0x0b, 0x71, 0x8a, 0x15, 0xed, 0xc0, 0x72, 0x2f,
	0x1e, 0x8f, 0x7c, 0xcc, 0xe8, 0x6b, 0xdd, 0x7b, 0x0c, 0x87, 0xa4, 0x02, 0xaa, 0x14, 0xef, 0x77,
	0x5d, 0x5e, 0xf6, 0x79, 0x7c, 0x81, 0x43, 0x82, 0x8e, 0xa0, 0x7a, 0xad, 0x67, 0x87, 0x49, 0xe6,
	0x14, 0xc9, 0xca, 0x40, 0x0b, 0x5f, 0x27, 0x72, 0x9e, 0xc2, 0xd4, 0x79, 0x40, 0xd0, 0x22, 0x14,
	0x02, 0xca, 0x48, 0x63, 0xdd, 0x74, 0xc1, 0x8c, 0x5c, 0xad, 0x77, 0xcd, 0x1b, 0xaa, 0x0f, 0x8c,
	0x79, 0xc3, 0x79, 0x63, 0xc1, 0x42, 0x5a, 0xb2, 0xa8, 0x06, 0xd3, 0xaa, 0x96, 0xac, 0xb1, 0xb5,
	0xa4, 0xfc, 0xd0, 0x36, 0xcc, 0x60, 0xe6, 0x77, 0xdb, 0xec, 0x61, 0x86, 0xcc, 0x66, 0xae, 0xee,
	0x49, 0x57, 0x57, 0x23, 0xd0, 0x0a, 0x40, 0x84, 0x99, 0x4f, 0x1a, 0x11, 0x16, 0xba, 0xe6, 0x2d,
	0xb7, 0xa4, 0x2c, 0x2e, 0x16, 0xc4, 0xf9, 0xd5, 0x82, 0x85, 0xaf, 0x18, 0xee, 0x60, 0x1a, 0xe0,
	0x0b, 0x1a, 0x50, 0xf1, 0xea, 0x6b, 0xca, 0x3c, 0x7e, 0x85, 0x96, 0xa1, 0x74, 0xa5, 0xfe, 0xeb,
	0xb5, 0xfc, 0xac, 0x36, 0x9c, 0x78, 0xd7, 0x1a, 0x77, 0xf2, 0xb6, 0x8d, 0x3b, 0x95, 0xbb, 0x71,
	0x9d, 0x7f, 0x2c, 0xa8, 0xca, 0xe9, 0x96, 0xb6, 0xd7, 0x5b, 0x4d, 0xe8, 0xff, 0x3f, 0x85, 0x0e,
	0x3c, 0x18, 0x91, 0x81, 0x99, 0xd7, 0x5f, 0x42, 0x41, 0xab, 0x6c, 0x26, 0x76, 0xbe, 0x8e, 0x4a,
	0xe3, 0x74, 0x0d, 0x91, 0xf3, 0xb7, 0x05, 0xef, 0xed, 0x79, 0x5e, 0xaa, 0xcf, 0x5b, 0x21, 0xdc,
	0x0e, 0xac, 0x66, 0xee, 0xdf, 0xc8, 0x36, 0xaa, 0x5a, 0x9d, 0x5d, 0x78, 0x70, 0x48, 0x02, 0x22,
	0xc8, 0x28, 0x09, 0x46, 0x32, 0xbc, 0x0f, 0xce, 0x28, 0x06, 0xf3, 0xd4, 0xf0, 0xdb, 0x24, 0xd8,
	0x47, 0xfd, 0x6a, 0x9d, 0x89, 0x88, 0xe0, 0xf0, 0x36, 0x22, 0xaf, 0x48, 0x91, 0x25, 0xb8, 0x21,
	0xb0, 0x6f, 0x86, 0x4a, 0x49, 0x5b, 0xce, 0xb1, 0x8f, 0xbe, 0x83, 0xf9, 0xde, 0x58, 0x14, 0x24,
	0x20, 0x21, 0x11, 0xd1, 0x2b, 0xa3, 0xe9, 0xd6, 0xcd, 0x86, 0xf0, 0x79, 0x02, 0x3f, 0x9e, 0x70,
	0x51, 0x3c, 0x64, 0x45, 0x47, 0x70, 0xcf, 0x6c, 0x85, 0x74, 0x08, 0x13, 0xe6, 0xfe, 0x73, 0x32,
	0x82, 0xe8, 0x94, 0x9f, 0x4b, 0xcf, 0xe3, 0x09, 0x77, 0x2e, 0xee, 0x2d, 0xf7, 0x4b, 0x50, 0x34,
	0x52, 0x38, 0x21, 0xa0, 0xe1, 0xf8, 0xd9, 0xcf, 0x18, 0x3b, 0x50, 0xea, 0x25, 0xa9, 0x2b, 0xae,
	0x9a, 0x11, 0xbf, 0xcb, 0xe6, 0xf6, 0x20, 0xce, 0xbf, 0x16, 0x2c, 0xa7, 0x1e, 0x8c, 0xa9, 0x9e,
	0xcc, 0xc0, 0xab, 0x30, 0x17, 0x19, 0x27, 0xf9, 0xa5, 0x3e, 0x07, 0x48, 0x4c, 0x27, 0x1e, 0xf2,
	0x01, 0xf5, 0xdf, 0x87, 0x61, 0x88, 0x99, 0x17, 0x9b, 0x73, 0x78, 0x76, 0xd3, 0xcb, 0x50, 0xa3,
	0x8f, 0x27, 0xdc, 0x72, 0x7c, 0xdd, 0xb8, 0x0f, 0x30, 0xdb, 0xad, 0xb3, 0x27, 0x50, 0x1e, 0x42,
	0xa1, 0x0a, 0x14, 0x4d, 0x7c, 0x35, 0x39, 0xee, 0xb9, 0xc9, 0x72, 0xe3, 0xaf, 0x22, 0x2c, 0x0c,
	0x66, 0x4f, 0x22, 0x75, 0x99, 0xff, 0x62, 0xc1, 0x52, 0x46, 0x63, 0xa1, 0x83, 0x5c, 0x9b, 0x1f,
	0x3d, 0x56, 0xec, 0xc3, 0xbb, 0x91, 0x98, 0xd3, 0xf9, 0x11, 0xa0, 0xf7, 0x88, 0x8e, 0xf2, 0xa9,
	0x3a, 0xf4, 0x06, 0x60, 0x6f, 0xdd, 0x18, 0x67, 0xc2, 0xff, 0x61, 0x81, 0x9d, 0xdd, 0xfc, 0xe8,
	0x45, 0x2e, 0xde, 0xb1, 0xf3, 0xc7, 0x3e, 0xba, 0x33, 0x8f, 0xd9, 0xef, 0x6b, 0x28, 0x75, 0x5f,
	0x03, 0xd0, 0x66, 0x2e, 0xd6, 0xeb, 0xaf, 0x3a, 0xf6, 0xb3, 0x9b, 0xc2, 0x4c, 0xec, 0xdf, 0x2d,
	0xb8, 0x9f, 0x79, 0xc7, 0xa1, 0xe7, 0xb9, 0x59, 0x47, 0xdd, 0xf2, 0xf6, 0x8b, 0xbb, 0xd2, 0x98,
	0xcd, 0xbe, 0xb1, 0x60, 0xe9, 0x65, 0x8b, 0xb0, 0x94, 0xc9, 0x80, 0x3e, 0xcb, 0x15, 0x23, 0x7b,
	0xd8, 0xdb, 0xbb, 0xb7, 0x27, 0xd0, 0xdb, 0x5b, 0xb3, 0x3e, 0xb6, 0xf6, 0x7f, 0xb2, 0xe0, 0x51,
	0x93, 0x87, 0x79, 0xb8, 0xf6, 0xd1, 0x00, 0xd9, 0xa9, 0xbc, 0x4f, 0x4f, 0xad, 0x6f, 0x76, 0x7d,
	0x2a, 0xbe, 0x6d, 0x5f, 0xc8, 0x47, 0xc3, 0x3a, 0x65, 0x97, 0xdc, 0x30, 0x51, 0xd6, 0xac, 0xfb,
	0xfc, 0x49, 0x8e, 0x1f, 0x09, 0x2e, 0x0a, 0xea, 0x6a, 0x7e, 0xfa, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x42, 0x44, 0xf5, 0x83, 0x52, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GroundStationServiceClient is the client API for GroundStationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GroundStationServiceClient interface {
	// Adds a new unavailability window to the requested ground station.
	//
	// Existing plans that overlap the unavailability window will not be canceled and the request will
	// be closed with a 'FAILED_PRECONDITION' status. In this case you will need to list any existing
	// plans with ListPlans and then cancel the plans with CancelPlan.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `start_time`, or `end_time` are missing, or 'end_time' is not after 'start_time'.
	AddUnavailabilityWindow(ctx context.Context, in *AddUnavailabilityWindowRequest, opts ...grpc.CallOption) (*AddUnavailabilityWindowResponse, error)
	// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
	// executed. This action cannot be undone, but it is still possible for the pass to be reserved
	// again. The plan cannot be cancelled less than ten minutes before AOS.
	//
	// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
	// for details.
	//
	// If the plan is not found, the request will return a `NOT_FOUND` error.
	//
	// If the plan has already been canceled or is less than ten minutes away from its AOS, the
	// request will return a `FAILED_PRECONDITION` error.
	//
	// If the plan is ongoing or has already finished executing, the request will return a
	// `OUT_OF_RANGE` error.
	CancelPlan(ctx context.Context, in *CancelPlanRequest, opts ...grpc.CallOption) (*CancelPlanResponse, error)
	// Deletes an existing unavailability window of the requested ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `window_id` is missing
	// or invalid.
	DeleteUnavailabilityWindow(ctx context.Context, in *DeleteUnavailabilityWindowRequest, opts ...grpc.CallOption) (*DeleteUnavailabilityWindowResponse, error)
	// Lists the plans for a particular ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error)
	// Returns a list of unavailability windows for the requested ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `start_time`, or `end_time` are missing, or 'end_time' is not after 'start_time'.
	ListUnavailabilityWindows(ctx context.Context, in *ListUnavailabilityWindowsRequest, opts ...grpc.CallOption) (*ListUnavailabilityWindowsResponse, error)
	// Open a stream from a ground station. The returned stream is bi-directional - it is used by
	// the ground station to send telemetry received from a satellite and receive commands to send to
	// the satellite. The ground station must keep this stream open while it is connected to the
	// StellarStation network for use in executing plans - if the stream is cut, it must be
	// reconnected with exponential backoff.
	//
	// The first `GroundStationStreamRequest` sent on the stream is used for configuring the stream.
	// Unless otherwise specified, all configuration is taken from the first request and configuration
	// values in subsequent requests will be ignored.
	//
	// There is no restriction on the number of active streams from a ground station (i.e., streams
	// opened with the same `ground_station_id`). Most ground stations will issue a single stream to
	// receive commands and send telemetry, but in certain cases, such as if uplink and downlink are
	// handled by different computers, it can be appropriate to have multiple processes with their
	// own stream. If opening multiple streams for a single ground station, it is the client's
	// responsibility to handle the streams appropriately, for example by ensuring only one stream
	// sends commands so they are not duplicated.
	//
	// If the ground station is not found or the API client is not authorized for it, the stream will
	// be closed with a `NOT_FOUND` error.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	OpenGroundStationStream(ctx context.Context, opts ...grpc.CallOption) (GroundStationService_OpenGroundStationStreamClient, error)
}

type groundStationServiceClient struct {
	cc *grpc.ClientConn
}

func NewGroundStationServiceClient(cc *grpc.ClientConn) GroundStationServiceClient {
	return &groundStationServiceClient{cc}
}

func (c *groundStationServiceClient) AddUnavailabilityWindow(ctx context.Context, in *AddUnavailabilityWindowRequest, opts ...grpc.CallOption) (*AddUnavailabilityWindowResponse, error) {
	out := new(AddUnavailabilityWindowResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.groundstation.GroundStationService/AddUnavailabilityWindow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groundStationServiceClient) CancelPlan(ctx context.Context, in *CancelPlanRequest, opts ...grpc.CallOption) (*CancelPlanResponse, error) {
	out := new(CancelPlanResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.groundstation.GroundStationService/CancelPlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groundStationServiceClient) DeleteUnavailabilityWindow(ctx context.Context, in *DeleteUnavailabilityWindowRequest, opts ...grpc.CallOption) (*DeleteUnavailabilityWindowResponse, error) {
	out := new(DeleteUnavailabilityWindowResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.groundstation.GroundStationService/DeleteUnavailabilityWindow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groundStationServiceClient) ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error) {
	out := new(ListPlansResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.groundstation.GroundStationService/ListPlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groundStationServiceClient) ListUnavailabilityWindows(ctx context.Context, in *ListUnavailabilityWindowsRequest, opts ...grpc.CallOption) (*ListUnavailabilityWindowsResponse, error) {
	out := new(ListUnavailabilityWindowsResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.groundstation.GroundStationService/ListUnavailabilityWindows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groundStationServiceClient) OpenGroundStationStream(ctx context.Context, opts ...grpc.CallOption) (GroundStationService_OpenGroundStationStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GroundStationService_serviceDesc.Streams[0], "/stellarstation.api.v1.groundstation.GroundStationService/OpenGroundStationStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &groundStationServiceOpenGroundStationStreamClient{stream}
	return x, nil
}

type GroundStationService_OpenGroundStationStreamClient interface {
	Send(*GroundStationStreamRequest) error
	Recv() (*GroundStationStreamResponse, error)
	grpc.ClientStream
}

type groundStationServiceOpenGroundStationStreamClient struct {
	grpc.ClientStream
}

func (x *groundStationServiceOpenGroundStationStreamClient) Send(m *GroundStationStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groundStationServiceOpenGroundStationStreamClient) Recv() (*GroundStationStreamResponse, error) {
	m := new(GroundStationStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GroundStationServiceServer is the server API for GroundStationService service.
type GroundStationServiceServer interface {
	// Adds a new unavailability window to the requested ground station.
	//
	// Existing plans that overlap the unavailability window will not be canceled and the request will
	// be closed with a 'FAILED_PRECONDITION' status. In this case you will need to list any existing
	// plans with ListPlans and then cancel the plans with CancelPlan.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `start_time`, or `end_time` are missing, or 'end_time' is not after 'start_time'.
	AddUnavailabilityWindow(context.Context, *AddUnavailabilityWindowRequest) (*AddUnavailabilityWindowResponse, error)
	// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
	// executed. This action cannot be undone, but it is still possible for the pass to be reserved
	// again. The plan cannot be cancelled less than ten minutes before AOS.
	//
	// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
	// for details.
	//
	// If the plan is not found, the request will return a `NOT_FOUND` error.
	//
	// If the plan has already been canceled or is less than ten minutes away from its AOS, the
	// request will return a `FAILED_PRECONDITION` error.
	//
	// If the plan is ongoing or has already finished executing, the request will return a
	// `OUT_OF_RANGE` error.
	CancelPlan(context.Context, *CancelPlanRequest) (*CancelPlanResponse, error)
	// Deletes an existing unavailability window of the requested ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `window_id` is missing
	// or invalid.
	DeleteUnavailabilityWindow(context.Context, *DeleteUnavailabilityWindowRequest) (*DeleteUnavailabilityWindowResponse, error)
	// Lists the plans for a particular ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListPlans(context.Context, *ListPlansRequest) (*ListPlansResponse, error)
	// Returns a list of unavailability windows for the requested ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `start_time`, or `end_time` are missing, or 'end_time' is not after 'start_time'.
	ListUnavailabilityWindows(context.Context, *ListUnavailabilityWindowsRequest) (*ListUnavailabilityWindowsResponse, error)
	// Open a stream from a ground station. The returned stream is bi-directional - it is used by
	// the ground station to send telemetry received from a satellite and receive commands to send to
	// the satellite. The ground station must keep this stream open while it is connected to the
	// StellarStation network for use in executing plans - if the stream is cut, it must be
	// reconnected with exponential backoff.
	//
	// The first `GroundStationStreamRequest` sent on the stream is used for configuring the stream.
	// Unless otherwise specified, all configuration is taken from the first request and configuration
	// values in subsequent requests will be ignored.
	//
	// There is no restriction on the number of active streams from a ground station (i.e., streams
	// opened with the same `ground_station_id`). Most ground stations will issue a single stream to
	// receive commands and send telemetry, but in certain cases, such as if uplink and downlink are
	// handled by different computers, it can be appropriate to have multiple processes with their
	// own stream. If opening multiple streams for a single ground station, it is the client's
	// responsibility to handle the streams appropriately, for example by ensuring only one stream
	// sends commands so they are not duplicated.
	//
	// If the ground station is not found or the API client is not authorized for it, the stream will
	// be closed with a `NOT_FOUND` error.
	//
	// Status: ALPHA This API is under development and may not work correctly or be changed in backwards
	//         incompatible ways in the future.
	OpenGroundStationStream(GroundStationService_OpenGroundStationStreamServer) error
}

func RegisterGroundStationServiceServer(s *grpc.Server, srv GroundStationServiceServer) {
	s.RegisterService(&_GroundStationService_serviceDesc, srv)
}

func _GroundStationService_AddUnavailabilityWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUnavailabilityWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroundStationServiceServer).AddUnavailabilityWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.groundstation.GroundStationService/AddUnavailabilityWindow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroundStationServiceServer).AddUnavailabilityWindow(ctx, req.(*AddUnavailabilityWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroundStationService_CancelPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroundStationServiceServer).CancelPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.groundstation.GroundStationService/CancelPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroundStationServiceServer).CancelPlan(ctx, req.(*CancelPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroundStationService_DeleteUnavailabilityWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUnavailabilityWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroundStationServiceServer).DeleteUnavailabilityWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.groundstation.GroundStationService/DeleteUnavailabilityWindow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroundStationServiceServer).DeleteUnavailabilityWindow(ctx, req.(*DeleteUnavailabilityWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroundStationService_ListPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroundStationServiceServer).ListPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.groundstation.GroundStationService/ListPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroundStationServiceServer).ListPlans(ctx, req.(*ListPlansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroundStationService_ListUnavailabilityWindows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnavailabilityWindowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroundStationServiceServer).ListUnavailabilityWindows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.groundstation.GroundStationService/ListUnavailabilityWindows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroundStationServiceServer).ListUnavailabilityWindows(ctx, req.(*ListUnavailabilityWindowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroundStationService_OpenGroundStationStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroundStationServiceServer).OpenGroundStationStream(&groundStationServiceOpenGroundStationStreamServer{stream})
}

type GroundStationService_OpenGroundStationStreamServer interface {
	Send(*GroundStationStreamResponse) error
	Recv() (*GroundStationStreamRequest, error)
	grpc.ServerStream
}

type groundStationServiceOpenGroundStationStreamServer struct {
	grpc.ServerStream
}

func (x *groundStationServiceOpenGroundStationStreamServer) Send(m *GroundStationStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groundStationServiceOpenGroundStationStreamServer) Recv() (*GroundStationStreamRequest, error) {
	m := new(GroundStationStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GroundStationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stellarstation.api.v1.groundstation.GroundStationService",
	HandlerType: (*GroundStationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddUnavailabilityWindow",
			Handler:    _GroundStationService_AddUnavailabilityWindow_Handler,
		},
		{
			MethodName: "CancelPlan",
			Handler:    _GroundStationService_CancelPlan_Handler,
		},
		{
			MethodName: "DeleteUnavailabilityWindow",
			Handler:    _GroundStationService_DeleteUnavailabilityWindow_Handler,
		},
		{
			MethodName: "ListPlans",
			Handler:    _GroundStationService_ListPlans_Handler,
		},
		{
			MethodName: "ListUnavailabilityWindows",
			Handler:    _GroundStationService_ListUnavailabilityWindows_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenGroundStationStream",
			Handler:       _GroundStationService_OpenGroundStationStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "stellarstation/api/v1/groundstation/groundstation.proto",
}
